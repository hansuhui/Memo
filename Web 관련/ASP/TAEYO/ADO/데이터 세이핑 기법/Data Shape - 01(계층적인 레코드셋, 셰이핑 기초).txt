[Data Shape - 01(계층적인 레코드셋, 셰이핑 기초)]


데이터 셰이핑을 첨 보았을 때 , 저는 이것은 대단히 어려운 기술일 것이라고 생각했었습니다.
첨 이를 접했을 때 선뜩 공부하고픈 마음이 들지 않았었으니 말입니다.

Professional 시리즈등 중급수준의 Wrox 책들을 통해서 이를 만나보았던 분이라면 어쩌면 
"이 기술은 내가 다루기엔 아직은 때가 아닌가 봐" 하실 수도 있을 것 같네요. 그렇습니다.
그리 쉽게 느껴지지 않을지도 모르겠습니다. 하지만, 제 생각에 레코드셋 객체를 어느 정도는
다룰 줄 알고 있으며, 또한, 가벼운 쇼핑몰 정도는 만들어 보신 수준이라면 데이터 셰이핑 기술은
그리 무리없이 같이 해나갈 수 있을 것이라고 생각해요.

이 강좌에서는 깊은 수준까지는 다루지 못할 것 같습니다... 하지만, 어느정도 응용이 가능한 정도의 수준까지...
간단한 예제를 몇가지 같이 해보아서... 우리의 내공을 같이 끌어볼려구 합니다.


1.계층적인 레코드셋

데이터 셰이핑은 사실 ADO 20.에서부터 지원되는 기능입니다. 이를 통해 여러분은 계층적인 레코드셋을
만들 수가 있게 되는 것이지요.. 계층적인 레코드셋

이미 계층형 게시판등을 만나본 여러분으로서는 계층형 이라는 말 자체에 그리 큰 부담을 느끼지는 않을 것입니다.
하지만, 계층형 레코드 셋이라면?

계층형 레코드 셋과 가장 비슷한 것은 바로 탐색기를 통해서 바라보는 여러 개의 폴더의 프리구조들입니다.
하지만, 계층형 레코드 셋이라면?

계층형 레코드 셋과 가장 비슷한 것은 바로 탐색기를 통해서 바라보는 여러 개의 폴더의 트리구조들입니다.
이는 계층형 레코드셋과 대단히 흡사하지요. 하나의 폴더 밑에 여러 개의 서브폴더가 있고, 그 서브폴더 밑에는 
또 많은폴더가 있을 수 있습니다. 그리고 그 폴더 안에도 여러 개의 파일과 폴더가 또한 있을 수 있고 말이지요.
계층형 레코드 셋은바로 이러한 모습과 비슷합니다.

하나의 레코드셋은 여러개의 레코드로 이루어 질수 있고, 그 레코드들중에 하나의 값으로 레코드셋이 들어있을 수 있구요.
그리고, 그 안의 레코드들 중에 레코드셋이 또 들어있을 수 있고 말입니다.

뭔가 어렵게 들린다면 간단하게 이렇게 생각해도 나쁘지는 않을 것 같아요.

계층적인 레코드셋의 특징중에 한가지를 쉽게 이야기하면 레코드셋 안에 레코드셋이 또 존재할수 있다는것!! 우리가 기존에
머리속에 그리고 있던 레코드셋의 모습은 아마도 그림 1과 같은 모습이었을 것입니다. 임시적인 테이블과 같은 모습 말입니다.
그러나, 이 모습이 실제모습은 아닐 것이며, 드단지 이해를 돕기 위해 제시하는 그림이라는 것을 기억해 주십시요..

또한, 그림의 레코드셋안의 데이터들은 의미가 없이 예를 위한 것이니 데이터 자체에 대해서는의미를 두지 마시기
바란답니다. 우리가 현재 유심히 보아야 할 것은 구조이니까요.


[그림1] - 그냥 일반적인 테이블 구조

일반적인 레콛드셋은 위처름 그림 1과 같은 모습을 가지고 있습니다. 그림 1의 경우 4개의 레코드를 가지고 있고,
각각의 레코드는 필드 컬렉션을 가지고 있지요. 그리고 그 필드 컬렉션은 6개의 필드들로 구성이 되어져 있고 말입니다.
다시 한번 강조하지만 이 그림은 단지 예를 위한 그림입니다. 특정인물과 장소와 관련없슴 입니다.

사실 실제의 레코드셋 객체나, 레코드객체, 필드컬렉션 개체와 필드개체들은 그림으로 보여지는 것 이상의 깊은 구성을 가지고 있습지요.
이 레코드셋이 데이터 셰이핑을 통해서 계층, 계통형이 되어진다면 하나의 필드안에 또 하나의 레코드 셋
객체가 그림 2 와 같이 들어갈 수가 있는 것입니다.


[그림2] - 레코드중 레코드 셋이 들어있는것(칼럼중 하나가 테이블 형식)

오옷~~ 이런 구성이 가능하다니??? 대단하지 않습니까?? (저의 이미지 편집 능력이 ) 그림 1과 비교해 보면
같은 데이블에 컬럼이 하나 추가 되어졌고, 그 각각의 칼럼의 값들로 레코드셋 객체가 통채로 들어서 있는 것을 볼 수 있습니다.
이 삽입(?)된 레코드셋은 각각의 레코드와 연관된 데이터들이지요.

굳이 예를 들자면, 계층적인 레코드셋은 Ms Access 2000에 추가된 기능중에 하나인 관계형 테이블 모습과 비슷하다고 볼 수 있습니다.
그림 2처럼 각각의 레코드와 연관된 테이블들이 Relation을 가지고 들어서 있는 모습을 볼 수 있는데, 이 모습이 마치 계층적인
레코드셋과 비슷하다고 볼 수 있을 것입니다.



[그림3] - 레코드 한줄에 하나의 테이블이 속하는것(어떤 회사에 판매상품 정보가 들어가는 개념)

위의 그림이 어떤 분에게는 도움스러울 수도 있지만, 어떤 분들은 오히려 더 헛갈리게 하는 것일지도 모르겠네요
이제 위의 그림을 머리 속에 넣고 조금은 개념적으로 알아보도록 하겠습니다.

여러분에게는 그림 3과 같은 두개의 테이블이 있다고 가정해 보도록 해요. 하나는 Goods 테이블이고, 
이곳에는 여러분의 상거랠 하기 위한 제품들의 간략한 정보들을 저장해 놓았다고 가정합니다. 그리고, 이 테이블과 연관하여
세부적인 제품내용들을 담고 있는 Goods_Detail 이라는 테이블이 있다고 가정하자구요. 
여러분은 어기서 어떤 종류의 제품의 상세내역을 가져와야 한다면 어떻게 해야 할까요?

아마도 여러분은 두 테이블을 조인하여 필요한 데이터들을 가져오려 할 것입니다.물론, 좋은 방법입니다. 하지만, 이렇게
가져온 데이터는 우리가 다루기 편리한 트리구조화 되어져 나오지는 못할 것이며, 트리구조를 만들기 위해 
추가적인 프로그래밍이 필요할 것입니다.



[그림4] - 테이블 2개가 FK로 이어져 있음

왜 트리구조화 해야 하냐구요? 왜 계층적인 레코드셋이 필요하냐구요? 왜? 왜?? 그냥 하면 안되냐구요...
뭐 그렇게 물어오신다면 할 말은 없습니다..

자전거 타고도 부산까지 갈 수 있는데, 왜 사람들은 주로 자동차를 타고 가는지... 그 이유와 비슷하지 않을까요??
다시 말해서, 트리 구조화되는 계층적인 레코드셋이 필요한 이유는 .. 그 이유는 거대한 데이터들을 분야별로 조직화(?)하여
관리하기 쉽게 하기 위함입니다.

왜 여러분이 여러분의 하드디스크의 많은 데이터들을 자신이 알아보기 쉬운 이름의 폴더를 만들고 분야별로, 종류별로 폴더안에
보관하는지를 생각해 보세요. 

관리가 유용하며, 여러분이 필요한 데이터를 찾기도 대단히 쉬어짐이 그 이유일 것입니다. 계층형 레코드셋이 필요한 이유도 바로
그것이며,계층형 레코드셋을 통해서 여러분은 여러분의 레코드셋들을 계층적으로, 조직적으로 관리하기가 용이해질 것이랍니다.

또한, 이 계층형 레코드셋의 결정적인 장점은 데이터의 업데이트에 있습니다. 테이블을 조인해서 데이터를 가져왔다고
하더라도 그 상태로는 데이터의 조회만이 목적일 뿐일 것입니다. 만일, 그 테이블들의 데이터를 업데이트 하고자 한다면,
각각의 테이블별로 데이터들을 업데이트하여야 할 것이지요??? 그렇습니다. 그런 경우는 쿼리를 이용해서 한번에 한 테이블만을
업데이트 할 수 있기에 말입니다. 하지만 , 계층적인 레코드셋은!!! 

일반 레코드셋처럼 그 상태에서 단지 필드의 값을 수정하고 Update 함으로써 쉽게 데이터를 업데이트 할 수 있게 됨다.
여러번의 쿼리는 필요치 않습니다.... 이 능력이 레코드셋 객체의 멋진 기능이기도 하지요...

사실 계층적인 레코드셋에도 여러 종류가 있습니다. 이것에는 크게 3가지가 있는데, 그들은 각각 관계 기반의 계층적 레코드셋과 
인자 기반의 계층적 레코드셋, 그리고 그룹기반의 계층적 레코드셋이지요. 이곳에서 각각에 대해 깊이 알아들어가는 것은 
우리 모두의 지나친 욕심이라고 생각하기에 간단히만 알아보고 넘어가도록 하겠습니다. 


====================================================
2.Shaping

위에서 공부한 내용을 기반으로 이제 데이터 셰이핑을 구현해보도록 하겠습니다..


데이터 셰이핑을 하기 위해서는 셰이핑 언어를 알아야 한답니다. 이것은 기존의 SQL 언어에 새로운 문법이 추가된 것이기에
그리 어렵지는 않을 것이예요. 하지만, 형식적으로는 전혀 새로워 보일 수도 있을 것 같네요.

데이터 셰이핑을 하기 위한 언어를 셰이핑 언어라고 하며, 이를 통해서 여러분은 계층적인 레코드셋을 만들어 낼 수 있게 됩니다.
데이터 셰이핑에 가장 많이 쓰이는 명령어로는 SHAPE, APPEND , RELATE가 있는데 이를 사용하는 가장 대표적인 구문을 먼저 
확인해 보도록 하겠습니다.

SHAPE {부모쪽의 sql query}
APPEND ({자식쪽의 sql query}
PELATE 부모쪽의 컬럼 TO 자식쪽의 컬럼 ) AS 별칭

오오. 뭔가 어렵습니다. 아직 SQL도 제대로 사용하지 못하는데, 왜 셰이핑 언어까지 배우라고 하는가?라고 불만을  토로하실지도
모르겠네요. 하지만, 조금만 시간을 투자하면 그리 어렵지 않은 것이니 부디 기본적인 것만큼은 알아두고 지나가심이...
첨에는 어려워 보이지만 데이터 셰이핑 기법을 차근히 익히게 된다면 여러분들은 기존의 동료직원들이 어려워하는 작업들을 대단히
쉽게 처리할 수도 있을 것입니다.

복잡한 Join이나 Group by를 사용하는 것보다는 휠씬 쉽게 여러 관련 테이블들간에서 원하는 데이터를 계층형으로 가져올 수 있을
것이니 말입니다.위에서 제시한 기본적인 SHAPE 구문은 그리 직관적이지 못할 것이예요. 그렇다면 다음의 구문은 어떠하신가요?
이 예문은 SQL 서버에서 기본적으로 제공되는 pubs 데이터베이스를 사용한 예이며, 이 장에서의 모든 예제도 그 샘플
데이터베이스를 사용할 것이랍니다..

SHAPE {SELECT * FROM Publishers}
APPEND ({SELECT * FROM employee}
RELATE pub_id TO pub_id ) as chEmp

아까보다는 휠씬 보기가 나을 것입니다. 이 구문의 목적은 출판사의 모든 데이터를 가져오면서, 각 출판사에 근무하는 사원들의
명단도 같이 가져오는 것입니다. 그럼 이 구문을 설명해 보겠습니다.

먼저 부모 테이블은 Publishers 테이블에서 모든 컬럼을 가져옵니다. 그리고, 이 테이블에 APPEND를 하는데 그 추가하는 테이블은
employee 테이블이랍니다. 즉, 마치 Publishers 테이블과 employee 테이블을 조인한 것처럼 데이터를 가져오게 한다는 것이죠.
그러나, 자식 테이블인 employee 에서는 모든 데이터를 다 가져오는 것이 아니라 부모 테이블의 pub_id 와 자식 테이블의
pub_id 값이 같은 데이터만을 각각 가져오게 하는 것입니다. 이렇게 가져온 테이블은 부모테이블에 chEmp라는 컬럼을 하나 추가하여
그것과 연결되어지게 합니다.

아아! 정말로 어렵구나! 라고 생각하기에는 아직 이릅니다!. 글만으로는 이것이 누구도 쉽게 이해가 가지 않을 것이기 때문이지요.
그렇다 하더라도 이것을 이해하는 것은 중요합니다. 이 구문이 가장 기본이 되는 구문이며, 이를 이해한다면 다른
구문들도 겁이 날것이 없으니까요.

이 구문의 결과를 단계를 통해 차근히 살펴보도록 합시다... 구문을 이해하는 것은 위의 구문을 한줄씩 따로 떼어내어서 다음 
단계를 따라서 이해하면 조금은 편하죠.


1. SHAPE {SELECT * FROM Publishers}

     : Publishers 테이블을 주로 하여 데이터를 셰이핑한다. 
      우선 Publishers 테이블의 모든 컬럼을 가져온다. 다음의 그림처럼 가져오게 될 것이다.



2. APPEND ({SELECT * FROM employee} 
    RELATE pub_id TO pub_id) as chEmp

       : 일단 APPEND는 생각하지 말도록 하자. 먼저 관심을 가질 부분은 괄호안에 위치한 
         {SELECT * FROM employee}  부분이다. 
         이것이 의미하는 것은 하나의 자식 테이블이다. 즉, employee 테이블을 모두 가져오는 것이다. 


  그리고, RELATE pub_id TO pub_id 이다. 이것은 부모 테이블과 자식 테이블간의 조건이다. 
	 즉, 부모 테이블의 pub_id 와 자식 테이블의 pub_id 가 같은 데이터만을 뽑아서 가져오는 것이다. 
         고로 그림 과 같은 employee 테이블이 만들어지는 것은 맞지만 그 안의 데이터는 pub_id가 
         일치하는 것들만으로 정리되게 되는 것이다.

         이 부분을 일반 쿼리로 표시하면 마치 다음과 같을 것이다. 
         SELECT * FROM employee WHERE pub_id = 부모테이블의 pub_id




3. APPEND ( ..... ) as chEmp

         : 현재 만들어진 자식 테이블을 부모테이블에 APPEND하는데, 부모테이블에 새롭게 chEmp라는
           컬럼을 생성하여 그 컬럼에서 자식 테이블을 참조하게 한다. 



	참고 : 추가된 chEmp 컬럼의 데이터 타입은? 

  데이터 셰이핑을 통해서 chEmp라는 컬럼이 새로 만들어졌는데 
  그렇다면 그 컬럼의 타입은 무엇일까? Varchar? Text? Image? 그것은 바로 adChapter 이다.
  왜 그런 이름이 붙여졌는지에 대해서는 언급이 없으며 단지 셰이핑을 통해서 추가되는 컬럼의 
  Type 는 adChapter 라는 것을 기억해 두기만 하면 될 것이다.




















