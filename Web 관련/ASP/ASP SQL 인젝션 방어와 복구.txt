요새 최대 화두는 SQL Injection 인 것 같습니다. 데이터베이스 백업을 잘 해 두었다면, 
공격을 당했더라도 복구하면 끝인데  백업이 안된 상태라면 큰 낭패입니다. 
그래도 스크립트 코드가 데이터의 뒷부분부터 삽입되었다면 
해당 스크립트만 제거하면 되는데 데이타의 본 부분을 잠식했다면 답이 없습니다. 
아래는 퍼온 글인데, 첫 부분의 Attach code in dbconn.inc 는 QueryString으로 넘어오는 Injection 공격에 대한 방어 
부분이고  그 아래의 sp 부분은 삽입된 스크립트를 제거하는부분입니다.
----------------------------------------    원 문     ------------------------------------------------
출처:http://zeshai.tistory.com/entry/SQL-injection-bjs
아놔... 며칠 간 저넘의.... sql injection 때메 고생 좀 했습니다.

미국에 있는 서버라 작업하기도 엄청 느리고...

요즘 유행인가 보네요, 봇으로... 무작위로 들어옵니다.

여러 좀비 서버에 js 파일들 배치시켜두고,  

database 테이블들에 varchar, text 이런 필드에 <script> 구문이나 <iframe>으로 넣어두고 있습니다.

여기 웹 사이트... 참조하시고...  http://isc.sans.org/diary.html?storyid=4565

대개 파일은 0.js 1.js b.js fuckjp.js  이런식이네요...


윈도우 서버라 asp 파일들이 데이터베이스에 접속하는 부분이 담긴 파일을 include 해서 사용합니다.

그 파일에 다음과 같은 내용을 추가해줍니다.

Attach code in dbconn.inc
<%
' Code for preventing SQL Injection
' Injection Keyword
array_split_item = Array("-", ";", "/*", "*/", "@@", "@", "char", "nchar", "varchar", "nvarchar", "alter", "begin", "cast", "create", "cursor", "declare", "delete", "drop", "end", "exec","execute", "fetch", "insert", "kill", "open","select", "sys", "sysobjects", "syscolumns","table", "update", "<script", "</script>", "'")
for each item in Request.QueryString
for array_counter = lbound(array_split_item) to ubound(array_split_item)
item_position1 = InStr(lcase(Request(item)), array_split_item(array_counter))
'Response.Write(array_split_item(array_counter) & "<BR>")

if item_position1 > 0 then
Response.Write("Command cannot be executed.")
Response.End()
end if

next
next
%>

그리고 SQL 서버에 다음의 두 쿼리를 날려서 SP 두개를 생성합니다.
Create FindReplace stored procedure
create PROCEDURE FindReplace
 (
 @TABLE  VARCHAR(200),
 @Field  VARCHAR(200),
 @WHERE VARCHAR(100),
 @Find  VARCHAR(500),
 @REPLACE  VARCHAR(500)
 )
 AS
 DECLARE @query VARCHAR(8000)
 SET @query  =  'UPDATE ' +  @TABLE +
                ' SET ' +  @Field + '= REPLACE(CONVERT(varchar(8000),'
               + @Field + '),''' +  @Find + ''',''' + @REPLACE  +''')'
 IF(@WHERE <> '')
         SET @query = @query + ' WHERE '+@WHERE
       
 EXECUTE (@query)
 GO

Create RemoveStringFinal Procedure
create Procedure RemoveStringFinal
 @FIND  VARCHAR(500),
 @REPLACE  VARCHAR(500)
as
DECLARE @TABLE_NAME VARCHAR(500)
DECLARE @COLUMN_NAME VARCHAR(500)
DECLARE @DATA_TYPE VARCHAR(500)
DECLARE db_cursor CURSOR FOR
  select  TABLE_NAME, COLUMN_NAME, DATA_TYPE FROM INFORMATION_SCHEMA.COLUMNS
OPEN db_cursor 
FETCH NEXT FROM db_cursor INTO @TABLE_NAME, @COLUMN_NAME, @DATA_TYPE
WHILE @@FETCH_STATUS = 0 
BEGIN 
       if @DATA_TYPE = 'varchar' or @DATA_TYPE = 'text' or @DATA_TYPE = 'ntext' or @DATA_TYPE = 'nvarchar'
          begin
     print @TABLE_NAME
            print @COLUMN_NAME
     print @DATA_TYPE
  
              EXEC FindReplace @TABLE_NAME,@COLUMN_NAME,'',@FIND,@REPLACE
          end     
       FETCH NEXT FROM db_cursor INTO @TABLE_NAME, @COLUMN_NAME, @DATA_TYPE
END
CLOSE db_cursor 
DEALLOCATE db_cursor

이제 exec로 SP를 써먹어 DB에 들어간 코드들을 지워줍니다.

제 서버에는 아래 <script>로 쌓인 데이터가 있어서 아래와 같이.. 싹 날려줬져...
심심하지 않은 이틀이었네요...

Run stored procedure example
EXEC RemoveStringFinal '<script src=http://www.alzhead.com/b.js></script>',''
EXEC RemoveStringFinal '<script src=http://www.chkbnr.com/b.js></script>',''
EXEC RemoveStringFinal '<script src=http://www.adwbnr.com/b.js></script>',''
EXEC RemoveStringFinal '<script src=http://www.coldwop.com/b.js></script>',''
EXEC RemoveStringFinal '<script src=http://www.chkadw.com/b.js></script>',''