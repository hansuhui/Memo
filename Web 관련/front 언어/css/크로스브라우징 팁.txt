[크로스브라우징 팁]

웹 표준에 관심이 있다면 웹 접근성이나 크로스 브라우징에도 관심이 있을 것입니다.
웹 접근성은 웹 표준의 상위목적이며 크소르 브라우징은 웹 접근성 가운데 Vendor 호환성을 충족하는 기술입니다.
간혼 '웹 표준 지키면 크로스 브라우징은 저절로 얻을 있는것 아니었어?'라고 생각하는 분들도 계신데 
이 자리에서 오해를 푸셨으면 합니다. 웹 표준 W3C 권장지침만 지키면 되는 것이지만 크로스 브라우징은
브라우저 제품별 특성(버그)을 모두 극복해서 동일하게 보이거나 또는 기능하도록 해야 하기 떄문에 휠씬 어렵고
예측불가능한 문제와 자주 만나게 됩니다. 웹 표준 방식의 코딩은 시간이 너무 많이 걸린다는 오해도 여기에서 비롯됩니다.
정확히 말하면 웹 표준 때문에 시간이 많이 걸리는 것이 아니라 브라우저 제품의 버그를 극복하는 과정(크로스 브라우징)이
개발자들의 시간을 좀먹고 있는 상황입니다. 만약 모든 브라우저의 렌더링 방식에 버그가 없다고 가정하면 '웹 표준 vs 비 표준'개발자가
동일 사이트를 개발한다고 했을 때 '백이면 백' 웹 표준 개발자의 코딩이 휠씬 빠를 것입니다. 
버그 투성이인 IE 브라우저 (암적인 존재)만 세상에서 사라져 준다면 이런 문제는 말끔하게 해결될 것 같은데 말이죠.
IE 생각할 수록 열받네요. 아래 설명중 제가 IE라고만 표기한 것은 IE6~7을 모두 포함합니다.


[바른 DTD(Document Type Definition)를 사용할것]

앞서 버그 투성이라고 소개했던 IE 조차도DTD만 제대로 적어주면 제법 표준에 따르는 렌더링 방식을 취하게 됩니다.
DTD를 적지 않으면 브라우저들은 Quirk Mode 상태(어물쩡한 상태)로 렌더링 하기 떄문에 바른 DTD를 적어주는 것은
크로스 브라우징의 첫 번쨰 원칙입니다. DTD 조차 정의하지 않은 상태로 크로스 브라우징 한다는 것은 애시당초 불가능 합니다.
현재 활성 버전의 HTML은 XHTML 1.0이므로 XHTML 1.0 DTD를 소개 합니다. 프레임셋 DTD와 호환모드 및 표준모드가 있는데
저는 호환모드를 권장합니다. 프레임셋 DTD는 프레임이 있는 문서의 프레임셋에 정의하는데 프레임은 강력하게 비추천 하므로
권장하지 않으며 표준모드는 강력하게 추천하지만 너무 엄격해서 이를 적용하기 어렵기 떄문에 소개하지 않겠습니다.
이래는 호환성을 고려하면서 약간은 느슨한 상태의 호환모드 DTD 입니다. 제 블러그의 DTD도 이것이고 제가 최근에 
개발하는 웹사이트의 DTD도 모두 이것입니다.

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



[의도하지 않았던 여백이 발생하는 경우 inline을 의심하거나 또는 그 면적을 float으로 없애줄것]

의도하지 않았던 애벽이 발생하는 경우는 보통 inline 형태의 element 문제 또는 IE의 버그 때문입니다. 
inline 형태의 element는 항상 line-height를 지니고 있습니다. 따라서 의도하지 않았던 여백이 발생하는 경우
일단 inline element의 line-height 문제가 아닌지 먼저 확인해 보아야 합니다. line-height도 화면에서 분명히 
면적을 차지하고 있습니다. 안타깝게도 line-height 속성을 CSS 에서 따로 정의하지 않았다면 웹 브라우저 제품마다 
line-heght 를 다르게 렌더링 할 것입니다. 이 때문에 어떤 브라우저에서는 의도한 대로 나타나지만 어떤 브라우저에서는 
박스와 박스 사이에 여백이 생길 수도 있는 것입니다. 또 다른 문제는 잘 알려진 IE 버그로서 block 된 li 에 발생하는 알 수 없는 
여백의 문제 입니다. 이럴 때에는 해당 li 가 화면에서 차지하는 면적을 제거하기 위하여 li {float:left; clear:both} 
를 적용하고 float 된 li 의 면적이 부모 element 에게는 유효하게 전달되도록 ul {overflow-hidden} 을 적용해 보시기 바랍니다. 
단, 이 팁이 모든 경우에 적당한 것은 아닐껍니다. 특히 세로 네비게이션 코딩시 문제가 발생하면 적용해 보시고 
다른 경우에도 적절하게 응용해 보시기 바랍니다.
설명을 듣고도 잘 해결이 되지 않으면 제게 문의해 주세요. 친절 A/S 해드리겠습니다.


[면적을 차지하는 것과 그렇지 않은 element 이해하기]

화면 레이아웃을 결정할 때 position 속성을 사용하거나 또는 float을 사용하라고 배윘을 것입니다.
{position:absolute} 상태일 떄에는 화면에서 면적을 차지하지 않는다는 것을 잘 알고 계실껍니다. 
그리고 {position:absolute} 상태일 때에는 그다지 렌더링 관련 버그를 만나는 경우가 없을 것입니다. 하지만 float의
경우 IE에서는 버그가 있으므로 FF, OP 브라우저와의 차이가 발견되면 일단 IE 를 믿지 마시기 바랍니다. 이것에 대한
문제해결은 float이 화면에서 면적을 차지하지 않는다는 사실과 IE에서는 이와 관련된 버그가 있다는 사실을 
인지하는 것으로부터 시작됩니다. 자주 발견되는 IE의 렌더링 오류는 float 된 요소와 float 되지 않는 요소가 만나는
방법입니다. float은 원래 주변의 inline 요소만 흐르도록 하는 것이 맞지만 IE 는 block 된 이웃 요소도 float의 영향을
받습니다. 