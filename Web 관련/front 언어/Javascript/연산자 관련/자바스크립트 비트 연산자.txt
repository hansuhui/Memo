[<< 연산자]

비트 연산자의 ES5 스펙 명칭은 비트 이동 연산자(Bitwise Shift Operator)이지만 일반적으로
비트 연산자라고 부르므로 이 책에서도 비트 연산자로 표기합니다. 비트 연산자에는
<<, >> , >>> 연산자가 있습니다.

비트는 0과 1로 구성되므로 2진수 연산을 하며 자바스크립트는 32비트 정수 연산을 합니다.
32번째 비트에 사인(sign) 부호가 설정되며 이 값이 0이면 양수 값을 , 1이면 음수 값을 나타냅니다.
비트 연산을 하는 가장 큰 장점은 연산 속도가 빠르다는 점입니다.

왼쪽 이동 연산자 (Left Shit Operator)는 << 로 표기하며 << 를 기준으로 왼쪽 값을 오른쪽에
지정한 수만큼 이동시킵니다. 왼쪽으로 이동하면 가장 왼쪽 비트는 오른쪽에서 이동한 비트 값으로
대체되며 이동한 오른쪽 비트에는 0이 설정됩니다. 이는 지정한 수만큼 2를 곱한것과 같습니다.

var value = 3; / 0011

value << 1; / 6(0110)

value << 2; / 12(1100)


[>> 연산자]

사인 부호 포함 오른쪽 이동 연산자(Signed Right Operator)는 >> 표기하며 >> 를
기준으로 왼쪽 값을 오른쪽에서 지정한 수만큼 오른쪽으로 이동시킵니다. 오론쪽으로 이동하면
가장 오른쪽 비트는 왼쪽에서 이동한 비트 값으로 대체되며 이동한 왼쪽비트에는 0이 설정됩니다.
단 양수/임수를 나타내는 32번째 비트의 값은 바뀌지 않습니다. 이는 지정한 수만큼 2로
나누고 소수 이하를 버린 정숫값과 같습니다.

var value = 10 (1010);

value >> 1; / 5(0101)

value >> 2; / 2(0010)



[2의 보수 표현법]

>>연산자로 음수를 처리하기 위해서는 우선 알고리즘(algorism)을 이해할 필요가 있습니다.
음수로 처리하는 방법 중에 2의 보수 표현법(two's complement)이 있습니다. 이는 각
비트 값을 반대 값으로 바꾸고 1을 더하는 방법입니다. 즉 0은 1로 , 1은 0으로 바꾸고 1을 더합니다.

ES5 스펙에 2의 보수 표현법을 사용하라고 기술되어 있지는 않습니다. 최종값을 구하는 
프로세스(process)가 개념적으로 작성되어 있으며 구현 방법은 기술되어 있지 않습니다.
구현을 자바스크립트 컴파일러 개발사에 일임한 것입니다. 그래서 결과는 같지만
브라우저 마다 성능에 차이가 있습니다.

-2의 보수 표현법

10진수 10을 2진수로 표현하면 아래 형태로 비트값이 설정됩니다.

00001010 (10)

이 형태에서 각 비트를 반대 값으로 바꾸면 아래 모습이 됩니다.

11110101 

여기에 1을 더하면 아래 모습이 됩니다.

11110110 (10의 2의 보수 표현)

[>> 연산자 음수 처리]

var value = -10; (11110110)

value >> 1

1비트 오른쪽으로 이동

11111011

여기서 1을 빼면 아래 모습이 됩니다.

11111010 (-5)

여기서 0과 1을 바꾸면

00000101 이되고 음수 부호를 붙이면 -5가 됩니다.


value >> 2

11111101

여기서 1을 빼면 

11111100

0을 1로, 1을 0으로 바꾸면 아래 모습이 되며 음수 부호를 설정하면 -3이 됩니다.


[>>> 연산자]

사인 부호 없는 오른쪽 이동 연산자(Unsigned Right Shift Operator)는 >>>로 표기하며
>>> 를 기준으로 왼쪽 값을 오른쪽에 지정한 수만큼 오른쪽으로 이동시킵니다.
여기까지는 >> 연산자와 처리 방법은 같습니다. >>>연산자는 가장 왼쪽에 양수, 음수를 나타내는
사인 부호도 이동된다는 점이 다릅니다.

값이 음수이면 가장 왼쪽의 사인 부호 값이 1입니다. 이 상태에서 오른쪽으로 이동하면 1이
오른쪽으로 이동하게 되어 음수를 나타내는 부호가 아닌 값이 됩니다. 사인 부호 비트에는
0이 설정됩니다.

var value = -1;
value >>> 1 / 2,147,483,647

2의 31승 값이 2,147,483,648 이므로 이 값에서 1을 뺀 값입니다.

value >>> 2 / 1,073,741,823

2의 30승 값이 1,073,741,824이므로 이 값에서 1을 뺀 값입니다.


[비트 OR 연산자]

바이너리 비트 연산자(Binary Bitwise Operators)에는 |,&,^ 연산자가 있으며 2항 연산자로
비트 단위로 연산합니다.

비트 OR 연산자(Bitwise OR Operator)는 |로 표기합니다. |를 기준으로 왼쪽 피연산자 값과
오른쪽 피연산자 값을 2진수 비트로 변환하여 연산합니다. 둘 중에 하나라도 비트 값이 1이면
1로 처리합니다.

2 | 5 / 7

아래에서 2진수로 2가 첫 번째 모습이고 5가 두 번째 모습입니다.

2진수 2

00000010

2진수 5

00000101

첫 번째와 두 번째 형태에서 하나라도 1이 있으면 1을 설정하므로 
아래 형태가 되어 7이 출력되었습니다.

2 | 5 결과

00000111 (OR게이트 인듯 !!! 두개의 비교 값중 1이라면 값을 1로 만든다!!)


[비트 AND 연산자]

비트 AND 연산자 (Bitwise AND Operator)는 &로 표기합니다. &를 기준으로
왼쪽 피연산자 값과 오른쪽 피연산자 값을 2진수 비트로 변환하여 연산합니다.
비트 값이 모두 1이면 1로 처리하고 그렇지 않으면 0으로 처리합니다.


2 & 5 / 0

아래에서 2진수로 2가 첫 번째 모습이고 5가 두번째 모습입니다.

2진수 2

00000010

2진수 5

00000101

첫번째와 두 번째에서 같은 위치의 값이 모두 1인 것이 하나도
없으므로 아래 형태가 되어 0이 출력되었습니다

00000000 (AND게이트 인듯 !!! 비교 값이 둘다 true일 경우에만 true이다)


[비트 XOR 연산자]

비트 XOR 연산자(Bitwise XOR Operator)는 ^로 표기합니다. ^를 기준으로 왼쪽 
피연산자 값과 오른쪽 피연산자 값을 2진수 비트로 변환하여 연산합니다.
같은 위치의 비트 값이 같으면 0이 되고 하나만 1이면 1이 됩니다.

3 ^ 5 / 6

2진수 3

00000011

2진수 5

00000101

첫 번째와 두 번째에서 가장 오른쪽 비트만 값이 같으므로 0으로 설정됩니다.
두 번째와 세 번째 비트는 값이 다르므로 1로 설정되어 6이 출력

3 ^ 5 결과

00000110 (XOR 게이트!!! 서로 다르면 1 서로 같으면 0)