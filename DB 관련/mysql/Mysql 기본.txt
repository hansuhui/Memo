SQL 문에서는 SQL 키워드와 함수 이름들은 대문자로 표시한다.
데이터베이스, 테이블, 칼럼 이름은 보통 소문자로 표시한다.
문법을 설명할때는 꺽쇠괄호[] 를 사용해 추가적인 정보를 나타낸다.
대안 리스트에서 수직 바 | 는 아이템들 사이의 구분ㄷ자로 사용된다.
[]로 둘러싸인 리스트는 선택가능하며, 리스트로부터 선택 가능한 아이템을 나타낸다. 
{}로 둘러싸인 리스트는 의무적이며, 리스트에서 반드시 선택해야만 하는 아이템을 나타낸다.

[구조적 용어]

데이터베이스는 저장하고자 하는 정보의 단순하고 규칙적인 형태로 구조화된 저장소를 의미한다.

- 데이터베이스 내 수집된 데이터들은 테이블로 구성된다.

- 각 테이블은 행과 칼럼 으로 구성된다.

- 테이블의 각 행을 행이라고 한다.

- 행들은 여러 조각의 정보를 포함한다. 테이블의 각 칼럼은 이런 조각중 하나와 일치한다.

[디비 접근]

SELECT * FROM 디비명.테이블

디비를 선택했다면 

SELECT * FROM 테이블


=============================[SQL문에서의 대소문자 구분]=============================
SQL 키워드와 함수명 : 대소문자 구분하지 않음

데이터베이스,테이블, 뷰이름 : 데이터베이스 취급에 따라서 달라짐
			      윈도우는 구분 X , 유닉스는 구분

저장 프로그램 이름 : 저장 함수와 프로시져명 , 이벤트 이름은 대소문자에 따라 달라지지 않음
		     트리거 이름은 대소문자 구분

칼럼 이름과 인덱스명 : 구분 하지 안음

문자열의 값 : 이진이 아닌지 이진인지에 따라 다름, 문자 세트 콜레이션에 따라 달라진다.

=======================================[인덱스 생성]=======================================

유니크 인덱스 : 유니크 인덱스는 여러 타입의 인덱스를 생성할 수 있다.

표준 인덱스 : 표준 인덱스는 인덱스의 장점을 제공하지만 중복을 허용한다.

FULLTEXT 인덱스 : 풀텍스트 검색을 수행할 때 사용된다. 이 인덱스 타입은 mYisam 테이블만
		   지원한다.

SPATIAL 인덱스 : 이 인덱스는 공간 데이터 값을 포함하는 MyISAM 테이블에서만 사용가능

HASH 인덱스 : BTREE 인덱스가 디폴트로 대신 생성되며 오버라이드할 수 있지만,
   	      MEMORY 테이블의 디폴트 인덱스 타입이다.

ALTER TABLE 테이블명 ADD INDEX 인덱스명 (해당 컬럼)
ALTER TABLE 테이블명 ADD UNUQUE  인덱스명 (해당 컬럼)
ALTER TABLE 테이블명 ADD PRIMARY KEY 인덱스명 (해당 컬럼)
ALTER TABLE 테이블명 ADD FULLTEXT 인덱스명 (해당 컬럼)
ALTER TABLE 테이블명 ADD SPATIAL 인덱스명 (해당 컬럼)


=================[스토리지 엔진 특성]===================

MySQL은 여러개의 스토리지 엔진(이전 명칭 테이블 핸들러)를 지원한다.
각 스토리지 엔진은 특정 특성들을 갖는 테이블을 구현한다.

스토리지 엔진 /  내용

ARCHIVE / 데이터 압축해 저장(삽입 후 행의 변경 없음)

BLACKHOLE / 쓰기는 무시하고 비어있는 값을 반환하는 엔진

CSV / 콤마로 구분된 값의 형태로 저장

FEDERATED / 원격 테이블 접속을 위한 엔진

InnoDB / 외래 키를 갖는 트랜잭션 엔진

MEMORY / 인메모리 테이블

MERGE / MyISAM 테이블의 집합 관리

MyISAM / 트랜잭션을 지원하지 않는 기본 스토리지 엔진

NDB / MySQL 클러스터용 엔진


엔진 사양 확인 쿼리
SHOW ENGINES  ;


Support에 칼럼 값이 yes 또는 NO 일 경우 엔진의 사용 가능 여부를 알려주고,
엔진이 존재하지만 꺼저 있을 경우 disabled로 서버가 기본적으로 사용하는 
엔진이라면 디폴트로 설정한다.
XA와 Savepoints는 엔진이 분산 트랜잭션과 부분 트랜잭션 롤백을 지워하는지 알려준다.


[InnoDB 스토리지 엔진]

InnoDB 스토리지 엔진은 서버를 따로 설정하지 않았다면 MySQL의 디폴트 엔진이다.

- 커밋과 롤백 기능이 있는 트랜잭션 세이프 테이블
 
- 세이브포인트는 부분 롤백을 가능하게 한다.

- 오작동 후 자동 복구 기능

- 연쇄적인 삭제와 갱신을 포함하는 외래 키와 참조 무결성 지원

- 검색과 갱신 둘다 포함하는 조건이 혼합된 질의에서 동시성 수행을 높이는 행 단위락과
  다중 버전 지원

- MySQL 5.6부터 풀텍스트 full-text 검색과 FULLTEXT 인덱스 지원

[MyISAM 스토리지 엔진]

- 일련의 비슷한 문자열 인덱스 값들을 저장할 때 키 축약 기능을 제공한다.
  숫자 값들은 높은 자리 바이트가 먼저 저장되기 때문에 유사한 일련의 숫자 인덱스 값들 또한
  축약할 수 있다.(인덱스 값들은 낮은 자리 바이트에서 더 빨라지는 경향이 있으므로 높은 자리
  바이트는 축약되야 한다.) 수치 축약을 활성화하려면 MyISAM 테이블을 생성할 때 
  PACK_KEYS=1 옵션을 사용한다.

- AUTO_INCREMENT 칼럼 기능이 다른 스토리지 엔진에 의해 제공되는 것보다 더 많다.

- 각 MyISAM 테이블은 테이블 점검 작업이 수행되는지 여부를 알려주는 플래그를 갖고 있다.
  서버가 비정상적으로 종료되거나 컴퓨터가 장애를 일으킬 경우 점검이 필요한 테이블을 찾아내기
  위해 플래그를 사용할 수 있다. 이를 자동으로 수행하고 싶다면 myisam_recover_options 
  시스템 변수를  FORCE 옵션이 포함된 값으로 설정한 후 서버를 시작하면 된다.

[임시테이블 생성]

존재하지 않는 테이블만 생성하려면 CREATE TABLE IF NOT EXISTS를 사용한다.
필요로 하는 테이블이 이미 설정이 됐는지 추정할 수 없는 애플리케이션에 이 질의문을
사용할 수 있다. 애플리케이션은 무작정 테이블을 생성할 수 있다.
IF NOT EXISTS 수정자는 특히 mysql로 배치 작업을 수행하는 스크립트에 사용된다.

[임시테이블 생성]

CREATE TEMPORARY TABLE TAMP 

[다른데이블 복사]

CREATE TABLE 새테이블명 LIKE 복사 테이블
CREATE TEMPORARY TABLE TAMP LIKE TEST

예제
CREATE TEMPORARY TABLE TAMP LIKE TEST;
INSERT INTO TAMP SELECT * FROM TEST;
SELECT * FROM TAMP

[데이터베이스 메타데이터 얻기]

MySQL은 데이터베이스 메타데이터, 즉 데이터베이스와 데이터베이스의 객체들에 대한 정보를
얻을 수 있는 여러가지 방법을 제공한다.

- SHOW DATABASES 나 SHOW TABLES 와 같은 SHOW 문

- INFORMATION_SCHEMA 데이터베이스의 테이블

- mysqlshow 나 mysqldump 같은 커맨드라인 프로그램

[SHOW를 이용해 메타데이터 획득]

MySQL은 많은 타입의 데이터베이스 메타데이터를 출력하는 SHOW문을 제공한다.
SHOW는 데이터베이스 내용을 지속적으로 파악하고 테이블 구조를 다시 한번 확인하는데
유용하다. 다음의 예제들은 SHOW 문이 어떻게 사용되는지 보여준다.
접근 가능한 데이터베이스 리스트를 출력한다.

SHOW DATABASES;

SHOW TABLES FROM 디비명;(임시 테이블은 나오지 않음)

SHOW COLUMNS FROM 테이블명;

SHOW INDEX FORM 테이블명;

SHOW TABLE STATUS FROM 디비명;



[INFORMATION_SCHEMA를 이용해 메타데이터 얻기]

데이터베이스에 대한 정보를 얻는 또 다른 방법은 INFORMATION_SCHEMA 데이터베이스에 접근하는
것이다. INFORMATION_SCHEMA는 SQL 표준에 기초한다. 즉, 콘텐츠 일부분은 MySQL에 국한됐지만,
접근 방식은 표준을 따른 다는 점이다. 이런 부분 떄문에 INFORMATION_SCHEMA는 완전히 MySQL에
국한돼 있는 SHOW문에 비해 휠씬 이용하기 쉽다.

SELECT 문을 통해 INFORMATION_SCHEMA에 접근하며 , 유연한 방식으로 사용 가능하다. 
SHOW문은 항상 고정된 세트의 칼럼을 출력하며 결과를 테이블에 나타낼수 없다. 
INFORMATION_SCHEMA로 SELECT 문은 출력 결과의 특정 칼럼을 지정할 수 있고 WHERE절은 
원하는 정보를 선택하는데 필요한 모든 수식을 지정할수 있다.
또한 조인 또는 서브 질의를 사용할 수 있고, 검색 결과를 추후에 처리할 수 있게 또 다른
테이블에 저장하기 위해 CREATE TABLE ... SELECT 나  INSERT INTO .. .SELECT 를 
사용할 수 있다.

INFORMATION_SCHEMA를 여러 종류의 데이터베이스 메타데이터를 위한 뷰 역할을 하는 테이블이
저장된 가상 데이터베이스로 생각해도 된다.
INFORMATION_SCHEMA가 어떤 테이블을 포함하는지 확인하려면 SHOW TABLES를 사용한다.

SHOW TABLES IN INFORMATION_SCHEMA;
SELECT * FROM INFORMATION_SCHEMA.COLUMNS;

- SCHEMATA , TABLES , VIEWS , ROUTINES , TRIGGERS , EVENTS , PARTITIONS, COLUMNS
  데이터베이스에 대한 정보 : 데이터베이스 내의 데이블 , 뷰 , 저장 루틴 , 트리거, 그리고 
  이벤트 함수 파라미터, 테이블 파티션, 그리고 테이블 내의 칼럼

- FILES : 테이블스페이스 데이터를 저장하기 위해 사용된 파일데 대한 정보

- TABLE_CONSTRAINTS, KEY_COLUMN_USAGE
  고유 값을 갖는 인덱스나 외래 키와 같은 제약사항을 갖고 있는 테이블과 칼럼데 대한 정보

- STATISTICS : 테이블 인텍스 특성에 대한 정보


[내부 조인]

SELECT 문에서 여러 테이블을 FROM절 내에 INNER JOIN으로 구분해서 명시한다면 MySQL은 
내부 조인을 수행하는데 , 그 결과 테이블의 행들을 다른 테이블의 행들과 매칭시킨 결과를 출력한다.

SELECT * FROM T1 INNTER JOIN T2;

모든 칼럼을 선택하고 싶지 않거나 왼쪽에서 오른쪽으로 보이는 순서를 바꾸고 싶을 경우
원하는 칼럼들을 콤마로 구분해 명시하면 된다.

테이블의 각 행을 다른 테이블의 각 행과 결합시켜 가능한 모든 조합을 생성하는 조인은
카르테시안 곱이라고 알려져 있다. 이런 방식으로 테이블을 조인시킨다면 생성될 행 수가
각테이블의 행 수의 곱과 같기 떄문에 굉장히 많은 숫자의 행들을 생성시킬 가능성이 있다.
각긱 100개 , 200개 , 300개의 행들을 포함하는 세 개의 테이블을 조인시킨다면 
100 * 200 * 300 = 600만 개의 행을 반환한다. 개별 테이블이 작은데도 불구하고
굉장히 많은 행들이다. 이런 경우 보통 WHERE 절이 좀 더 관리하기 쉬은 크기로 
결과 세트를 줄여주기에 유용하게 쓰인다.

테이블들이 특정 칼럼들의 값끼리 매칭되게 WHERE 절을 추가하면 조인은 해당 칼럼중 
동일한 값을 갖는 행들만 선택한다.

SELECT * FROM T1 INNTER JOIN T2 WHERE T1.I1 = T2.I1;

CROSS JOIN 과 JOIN 타입은 INTER JOIN 과 같으므로 다음 질의문들은 모두 동일하다.

SELECT * FROM T1 INNTER JOIN T2 WHERE T1.I1 = T2.I1;
SELECT * FROM T1 CROSS JOIN T2 WHERE T1.I1 = T2.I1;
SELECT * FROM T1 JOIN T2 WHERE T1.I1 = T2.I1;

WHERE 절보다 ON절을 사용

USING() 절을 포함하는 또 다른 문법으로 , ON과 개념이 유사하지만 조인된 칼럼 
또는 칼럼들의 이름이 각 테이블에서 동일해야 한다.

SELECT T1.*,T2.* FROM T1 INNER JOIN T2 USING(B);

LEFT JOIN

[ALL,ANY,SOME 서브 질의]

ALL과 ANY 연산자는 칼럼 서브 질의의 결과를 테스트하기 위해 상대 비교 연산자와 함께
사용된다. 비교 값이 서브 질의에 의해 반환된 값의 일부 또는 전체과 특정 관계가 있는지
여부를 테스트한다. 예를 들면 <= ALL 은 비교 값이 서브 질의가 반환한 모든 값보다
작거나 동일하면 참이지만 <= ANY는 비교 값이 서브 질의가 반환한 값의 일부 또는
전체보다 작거나 동일하면 참이다. SOME은 ANY의 동의어다.

SELECT * FROM 테이블 WHERE 조건칼럼 <= ALL (서브 쿼리)
SELECT * FROM 테이블 WHERE 조건칼럼 <= ANY (서브 쿼리)


[EXISTS 와 NOT EXISTS 서브 질의]

EXISTS 와 NOT EXISTS 연산자는 단순히 서브 질의가 행을 반환하는지 여부를 테스트 한다.
반환한다면 EXISTS는 참이고 , NOT EXISTS는 거짓이다. 다음 질의문은 이 서브 질의들의 
작은 예제들을 보여준다. 첫 번째 질의문은 absence 테이블이 비었다면 0을 반환하고,
두 번째 질의문은 1을 반환한다.

SELECT  EXISTS (SELECT * FROM absence);
SELECT NOT EXISTS (SELECT * FROM absence);

EXISTS 와 NOT EXISTS는 사실 상관 서브 질의에서 더 흔히 사용된다.
EXISTS 와 NOT EXISTS를 사용할 때 서브 질의는 출력 칼럼 리스트로 *을 사용한다.
서브 질의는 행이 포함할 수도 있는 특정 값이 아니라 행 반환 여부에 따라 참 또는 거짓을
정하기 때문에 칼럼 이름을 명시적으로 지정하지 않아도 된다. 
실제로 서브 질의 칼럼 선택 리스트를 위해 무엇이든 쓸 수 있지만, 서브 질의가 성공할 경우
참 값을 반환한다고 명시적으로 사용하고 싶다면 SELECT * 대신 SELECT 1 을 써도 된다.

[상관 서브 질의]

서브 질의는 상관관계가 없거나 있을 수 있다.

- 비상관 서브 질의는 외부 질의의 값에 대한 참조가 ㅇ벗으므로 분리된 질의문으로 단독 
  실행될 수 있다. 예를 들면 다음 질의문의 서브 질의는 테이블 t1만 참조하고, t2는 참조하지 
  않기 때문에 상관 관계가 없다.

 SELECT j FORM t2 WHERE j IN (SELECT i FORM t1)

- 상관 서브 질의는 외부 질의의 값에 대한 참조를 포함하며 , 그의 따라 이에 의존적이다.
  이런 결환 관계 대문에 상관 서브 질의는 분리된 질의문으로 단독 실행될 수 없다.
  예를 들면 다음 질의문의 서브 질의는 t1에 있는 칼럼 i와 대응되는 t2에 있는 칼럼 j의
  각 값에 대해 참이다.

 SELECT j FORM t2 WHERE j IN (SELECT i FORM t1 WHERE i = j);

상관 서브 질의는 흔히 EXISTS 와 NOT EXISTS 서브 질의로 사용되는데 , 이는 테이블 내에서
다른 테이블과 일치하거나 일치하지 않는 행을 찾는데 유용하다.

SELECT * FROM T1 WHERE EXISTS 
(SELECT * FROM T2 WHERE T1.칼럼 = T2칼럼 );


[여러 테이블 삭제와 수정]

어떤 경우에는 행을 삭제할 때 해당 행이 다른 테이블의 행과 매치되는지 아닌지에 대한 정보가
유용하게 사용되기도 한다. 마찬가지로 어떤 행을 수정할 때에도 종종 다른 테이블의 행 내용을 
유용하게 사용하곤 한다. 이 절에서는 여러 테이블의 수정과 삭제 방법을 설명한다.

DELETE T1 FROM INNER JOIN T2 ON T1.ID = T2.ID;

하나 이상의 테이블에서 동일한 칼럼 이름을 사용하고 있다면 칼럼의 구분이 혼동되기 때문에
반드시 테이블 이름과 함께 명세해야 한다.
이와 유사한 방법으로 여러 테이블의 행을 한 번에 삭제하는 것도 가능하다 , 즉
2개의 테이블에서 ID 값이 매체되는 행을 양족에서 삭제하려고 한다면 DELETE 키워드
뒤에 다음과 같지 테이블 이름을 나열해주면 된다.

DELETE T1,T2 FROM INNER JOIN T2 ON T1.ID = T2.ID;

매치되지 않는 관계의 행을 삭제하고 싶다면 어떻게 해야 할까? 여러 테이블에 대한 
DELETE 질의는 다양한 종류의 SELECT 질의를 조인해서 작성할 수 있으므로,매치되지 
않는 행을 식별하는 SELECT 질의를 작성해 사용하면 된다. 

DELETE T1 FROM T2 INNER JOIN T2 ON T1.ID = T2.ID;

UPDATE T2,T2 SET T2.A = T1.A WHERE T2.ID = T1.ID;

[트랜잭션]

트랙잭션이 적용된 시스템은 전형적으로 ACID 속성에 의해 특징화 된다. ACID는 트랜잭션이
가져야할 4가지 속성인 원자성 , 일관성 , 고립성 , 지속성의 앞머리를 딴 약자이다.

- 원자성 : 트랜잭션을 구성하는 질의문들은 하나의 논리적인 단위를 형성한다.
           따라서 이들 중 일부만 수행되지 않는다.

- 일관성 : 데이터베이스는 트랜잭션을 수행하기 전과 수행한 후가 일관적이어야 한다.
   	   예를 들어 한 테이블의 행에 포함된 ID가 다른 어떤 테이블에 항상 준재해야 하는
   	   관계라면 인증되지 않는 ID를 갖는 행을 테이블에 추가하는 트랜잭션이 있을 때
  	   이 동작은 실패하고 트랜잭션은 롤백될 것이다.

- 고립성 : 하나의 트랜잭션은 다른 트랜잭션에 영향을 미치지 않는다. 따라서
 	   동시에 수행된 트랜잭션은 하나씩 순차적으로 수행된 트랜잭션 결과와 동일하다.

- 지속성 : 트랜잭션이 성공적으로 수행됐다면 이결과는 데이터베이스에 영구적으로 반영된다.

트랜잭션은 데이터베이스의 수행 결과를 확실히 보장하지만, CPU 사이클이나 메모리,
저장 공간에 댛란 오버헤드를 유발하기도 한다. MySQL은 트랜잭션을 지원하거나
트랜잭션을 지우너하지 안는 스토리지 엔진을 제공한다.
트랜잭션의 속성이 어떤 애플리케이션에서는 필수적이지만 그렇지 않는 경우도 있으므로, 어떤것이
적합한 엔진인지 생각해보고 선택하면 된다. 금융거래는 전형적으로 트랜잭션이 필요한 
애플리케이션으로 오버헤드를 최소화하는 것보다 데이터 무결성을 보장하는 것이 우선적이다.
반면 웹 페이지의 로그를 수직하는 애플리케이션의 겅우 서버 에러시 작성되는 행이 
몇 개쯤 손시되는 것은 괜찮다. 
이 경우 트랜잭션을 지원하지 않는 스토리지 엔진을 사용함으로써 트랜잭션 처리로 발생하는
오버헤드를 피할수 있다.

기본적으로 MySQL은 오토 커밋 모드로 수행되므로 , 각 질의문으로부터
발생한 변경은 데이터베이스에 즉각 커밋돼 반영된다.
사실상 각 질의문은 암묵적으로 자신만의 트랜잭션을 갖고 있다.
트랜잭션을 명시적으로 수행하기 위해서는 오토커밋 모드를 중지하고 MySQL에 직접 커밋과
롤백 시점에 대해 알려줘야 한다.

트랙잭션을 수행하는 첫 번째 방벅는 START TRANSACTION(혹은 BEGIN)을 수행해
오토 커밋 모드를 중지하고 , 트랜잭션을 구성하는 질의문을 수행한 후 질의 마지막에 COMMIT를
추가해 결과를 데이터베이스에 반영하는 것이다.
트랜잭션을 수행하는 도중 에러가 발생한 경우 변경된 내용을 취소하는 대신 ROLLBACK을
수행해 트랜잭션을 취소한다. START TANSCTION이 수행되지 바로 이전의 모드 생태로
돌아가게 해줄 것이고, 비활성화된 상태였다면 현재 트랜잭션을 종료하고 그 다음 트랜잭션을
수행할 것이다.

예제 

START TRANSACTION;
쿼리문

SAVEPOINT 포인트명;
쿼리
ROLLBACK TO SAVEPOINT 포인트명;

COMMIT; OR ROLLBACK;


[숫자 자료형]

타입이름 / 의미

TINYINT / 아주 작은 정수

SMALLINT / 작은 정수

MEDIUMUNT / 중간 크기의 정수

INT / 표준 정수

BIGING / 큰 정수

DECIMAL / 고정소수점 수

FLOAT / 단정도 부동소수점 수

DOUBLE / 배정도 부동소수점 수

BIT / 비트 필드


[문자열 자료형]

타입이름 / 의미

CHAR / 고정 길의의 이진이 아닌(문자) 문자열

VARCHAR / 가변 길이의 이진이 아닌 문자열

BINARY / 고정 길이의 이진 문자열

VARBINARY / 가변 길이의 이진 문자열

TINYBLOB / 아주 작은 BLOB (binary large object)

BLOB / 작은 BLOB 

MEDIUBLOB / 중간 크기의 BLOB

LONGBLOB / 큰 BLOB

TINYTEXT / 이진이 아닌 아주 작은 문자열

TEXT / 이진이 아닌 작은 문자열

MEDUIMTEXT / 이진이 아닌 중간 크기의 문자열

LONGTEXT / 이진이 아닌 큰 문자열

EUMN / 열거형. 각 칼럼 값에 열거형 멤버를 하나씩 할당한다.

SET / 집합형. 각 칼럼 값에 멤버를 할당하지 않거나 하나 이상을 할당한다.


[시간적인 자료형]

DATE / 'CCYY-MM-DD' 형식의 날짜 값

TIME / 'hh:mm:ss' 형식의 시간 값

DATETIME /'CCYY-MM-DD hh:mm:ss' 형식의 날짜 값

YEAR / CCYY 또는 YY 형식의 연도 값


[시퀸스로 작업]

- 일반적인 AUTO_INCREMENT 속성

- 테이블당 AUTO_INCREMENT 속성을 갖는 칼럼은 하나만 가능하며, 정수형 자료형을 가져야한다.

- 칼럼은 반드시 인덱스돼야 한다. PRIMARY KET 나 UNIQUE 인덱스를 사용하는 방법이 가장
  일반적이지만, 고유하지 않은 인덱스를 사용할 수도 있다.

- 칼럼은 반드시 NOT NULL 제약을 갖고 있어야 한다.

- AUTO_INCREMENT 칼럼에 NULL을 입력하면 MySQL은 다음 시퀸스 번호를 생성한다.

- 가장 최근에 생성된 시퀸스 번호를 얻을려면 LAST_INSERT_ID() 함수를 호출한다.

[산술 연산자]

연산자  / 의미

+ / 덧셈

- / 뺄셈

-A / 부호 연산자 

* / 곱셈

/ / 나눗셈

DIV / 나눗셈 / 피연산자들의 정수형 몫

% / 나머지(모듈로)


[논리 연산자]

AND,&& / 논리곱

OR,|| / 논리합

XOR / 배타적 논리합 , 정확히 하나의 피연산자만 참이면 참

NOT / 논리 부정


[타입변환]

CONCAT(문자,문자,문자) : 함수는 문자열을 접합시켜 그 결과 더 긴 문자열을 생성한다.
	         	 숫자들은 문자열로 변환후 조합

REPEAT(문자,숫자) : 문자반복 

[뷰 사용]

CREATE VIEW 뷰명 AS 쿼리

[프로시져]

CREATE PROCEDURE 프로시져명 (파라미터 타입)
BEGIN

쿼리1;
쿼리2;

END;

CALL 프로시져명();

[저장 함수]

CREATE FUNCTION 함수명 (파라미터 타입)
RETURN type
routine_stmt

CREATE FUNCTION 함수명 (파라미터 타입)
RETURN type
BEGIN

END

SELECT 함수명(파라미터);

[트리거]

CREATE TRIGGER 트리검명
{BEFORE | AFTER } 트리거 활성화 될때
{INSERT | UPDATE | DELETE} 활성화 질의문
ON 테이블명
FOR EACH ROW trigge_stme 트리거하는일

CREATE TRIGGER 트리거명 
BEFORE INSERT ON 테이블명
FOR EACH ROW 
BEGIN
쿼리 
END 

[이벤트]

MySQL은 시간에 따라 활성화되는 데이터베이스 작업을 수행할 수 있게 
이벤트 스케줄러를 지원한다. 이베트는 스케줄러에 관련된 저장 프로그램이다.
스케줄은 이벤트가 실행되는 시간이나 , 시간들과 옵션으로 이벤트가 종료하기 위해
멈추는 시간도 정의한다. 이벤트는 특히 주기적으로 요약 보고서의 주기적인 업데이트,
오래된 데이터의 만료 , 또는 로그 테이블 교체 같이 지켜보는 사람 없이도 알아서 
수행되야 하는 관리 작업을 수행하는데 유용하다.

스케줄러의 상태 확인 질의

SHOW variables LIKE 'event_scheduler'

실행 시간에 스케줄러를 멈추거나 시작하려면 

SET GLOBAL event_scheduler = OFF OR 0
SET GLOBAL event_scheduler = ON OR 1

스케줄러를 중단시키면 이벤트는 실행되지 않는다. 또한 나중에 설명하겠지만, 
스케줄러는 계속 실행되게 하면서 개별적인 이벤트는 비활성화시킬 수 있다.

CREATE EVENT 이벤트명
ON SCHEDULE\



 







