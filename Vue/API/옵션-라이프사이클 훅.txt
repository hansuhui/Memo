[옵션 / 라이프사이클 훅]

모든 라이프사이클 훅은 자동으로 this 컨텍스트를 인스턴스에 바인딩하므로 데이터,계사뇐
속성 및 메소드에 접근할 수 있습니다. 즉, 화살표 함수를 사용해 라이프사이클 메소드를 정의하면
안됩니다.(예: create: () => this.fetchTodos() ) 이유는 화살표 함수가 부모 컨텍스트를 
바인딩 하기 때문에 this는 예상대로 Vue 인스턴스가 아니며 this.fetchTodos 는 정의되지 않습니다.

# beforeCreate

- 타입: Function

- 상세:
 
  인스턴스가 방금 초기화 된 후 데이터 관찰 및 이벤트 / 감시자 설정 전에 동기적으로
  호출 됩니다.

- 참고 : 라이프사이클 다이어그램


# created

- 타입: Function

- 상세:

  인스턴스가 작성된 후 동기적으로 호출됩니다. 이 단계에서 인스턴스는 데이터 처리,
  계산된 속성, 메서드, 감시/이벤트 콜백 등과 같은 옵션 처리를 완료합니다.
  그러나 마운트가 시작되지 않았으므로 $el 속성을 아직 사용할 수 없습니다.

- 참고 : 라이프사이클 다이어그램

# beforeMount 

- 타입: Function

- 상세:

  마운트가 시작되기 바로 전에 호출됩니다. render 함수가 처음으로 호출됩니다.
  이 훅은 서버측 렌더링 중 호출되지 않습니다.

- 참고 : 라이프사이클 다이어그램


# mounted

- 타입: Function 

- 상세:

  el이 새로 생성된 vm.$el 로 대체된 인스턴스가 마운트 된 직후 호출됩니다.
  루트 인스턴스가 문서 내의 엘리먼트에 마운트 되어 있으면, mounted 가 호출 될 때
  vm.$el 도 문서 안에 있게 됩니다.

  mounted는 모든 자식 컴포넌트가 마운트 된 상태를 보장하지 않습니다. mounted 내부에서
  vm.$nextTick를 사용하면 전체가 렌더링된 상태를 보장합니다.


mounted : function () {
  this.$nextTick(function () {
    // 모든 화면이 렌더링된 후 실행합니다.
  })
}

이 훅은 서버측 렌더링 중 호출되지 않습니다.

- 참고 : 라이프사이클 다이어그램


# beforeUpdate

- 타입: Function

- 상세:

  데이터가 변경되면, 가상 DOM 재 랜더링과 패치가 이뤄지기 전에 호출됩니다.
  이 훅에서 더 많은 상태 변경을 수행할 수 있으며 추가로 재 렌더링을 트리거 하지 않습니다.

  이 훅은 서버측 렌더링 중 호출되지 않습니다.

- 참고 : 라이프사이클 다이어그램


# updated

- 타입: Function

- 상세:
  
  데이터가 변경되어 가상 DOM이 재 렌더링되고 패치되면 호출됩니다.
 
  이 훅이 호출되면 엘리먼트의 DOM이 업데이트 된 상태가 되어 이 훅에서 DOM 종속적인
  연산을 할 수 있습니다. 그러나 대부분의 경우 무한루프가 발생할 수 있으므로 훅에서
  상태를 변경하면 안됩니다. 상태 변화에 반응하기 위해서 계산된 속성 또는 
  [감시자(#watch)]를 사용하는 것이 더 좋습니다.

  updated는 모든 자식 컴포넌트가 재-렌더링 된 상태를 보장하지 않습니다.
  updated 내부에서 vm.$nextTick를 사용하면 전체가 업데이트된 상태를 보장합니다.


updated: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been re-rendered
  })
}

이 훅은 서버측 렌더링 중 호출되지 않습니다.

- 참고 : 라이프사이클 다이어그램


# activated

- 타입: Function

- 상세:
 
  keep-alive 인 컴포넌트가 활성화 될 떄 호출됩니다.

  이 훅은 서버측 렌더링 중 호출되지 않습니다.

- 참고:

  내장 컴포넌트 - keep-alive
  동적 컴포넌트 - keep-alive


# beforeDestory

- 타입: Function

- 상세:
  
  Vue 인스턴스가 제거되기 전에 호출됩니다. 이 단계에서 인스턴스는 아직 완벽하게 동작합니다.
  
  이 훅은 서버측 렌더링 중 호출되지 않습니다.

- 참고 : 라이프사이클 다이어그램


# destroyed

- 타입: Function

- 상세:

  Vue 인스턴스가 제거된 후 호출됩니다. 이 훅이 호출되면 Vue 인스턴스의 모든 디렉티브가
  바인딩 해제 되고 모든 이벤트 리스너가 제거되며 모든 하위 Vue 인스턴스도 삭제됩니다.

  이 훅은 서버측 렌더링 중 호출되지 않습니다.

- 참고 : 라이프사이클 다이어그램


# errorCaptured

2.5.0+에서 추가됨

- 타입: (err: Error, vm: Compoent, info: string ) => ?boolean

- 상세:

  자손 컴포넌트로부터의 에러가 캡처되었을 때에 불립니다. 오류를 트리거 한 컴포넌트
  인스턴스 및 오류가 캡처된 위치에 대한 정보가 들어있는 문자열의 세 가지 전달인자를 받습니다.
  훅은 false 를 반환하여 오류가 더 전파되지 않도록 할 수 있습니다.

! 이 훅에서 컴포넌트 상태를 수정할 수 있습니다. 그러나 오류가 캡처되었을 때
  다른 내용을 더이상 실행시키지 않는 조건부 템플릿을 사용하거나 렌더링 기능을 사요하는 것이
  중요합니다. 그렇지 않으면 컴포넌트가 무한 렌더링 루프에 던져 질 것입니다.


에러 전파 규칙

- 기본적으로 모든 오류는 정의 된 겅우 전역 config.errorHandler 로 보내지므로 분석서비스에 
  한 곳에 보고할 수 있습니다.

- 여러 개의 'errorCaptured' 훅이 컴포넌트의 상속 체인이나 부모 체인에 존재하면, 
  모두 동일한 에러로 호출됩니다.

- errorCaptured 훅에서 에러를 throw 하면, 이 에러와 원래 캡쳐 된 에러 모두가 글로벌
  config.errorHandler 로 보내집니다.

- errorCaptured 훅은 오류가 더 전파되지 않도록 false를 반환 할 수 있습니다.
  이것은 본질적으로 "이 오류가 처리되었으므로 무시해야합니다."를 의미합니다.
  추가로 errorCaptired 훅이나 글로벌 config.errorHandler가 이 에러를 위해 
  호출되지 않도록 합니다.


 


































