[진행방향]

-중점 방향
정규표현식은 기호를 사용하여 구현
기호를 외울 필요 없음
전체 기능을 파악하여 두고
구현할 때는 메모,예제, 검색 활용


-진행 방법
개념, 논리, 기능 설명
예제 코드 코등
그룹 단위 실습


[타임 테이블]


분류 / 주요 내용

정규 표현식 개요 / 개요 , 3대 요소 , 패턴 , 매치 , 작성 방법
문자열 매치 / 플래그 , 대체 , 앞뒤 문자 매치 , 공백 문자 , 줄 분리자
매치 위치 패턴 / 처음부터 매치 , 끝에 매치 , 63개 문자 매치 , 단어 경계

정규 표현식 메소드 / 매소드 인식, match(),search(),split(), replace(),test(),exec()
수량자 패턴 / 욕심 많은 매치, 매치 범위 지정 , 욕식 없는 매치 , 정규 표현식 최적화

문자 클래스 / 문자 집합 , 문자화 , 백스페이스 , 구간 , 제외
이스케이프 클래스 / 숫자 매치 , 보이지 않는 문자 매치 , 63개 문자 매치 , 유니코드 매치

그룹화 / 캡처 , 백레퍼런스 , 캡처 값 참조 , 전방 매치 , 전방 부정 매치
RegExp 오브젝트 / 인스턴스 생성 , exec() , test(), tpStriong()


[정규 표현식]

-Regular Expression
약칭 : 오브젝트 이름인 RegExp

-한글
정규 표현식, 정규 표현

-모습
숫자 여부 테스트
/^\-\d+$/.test("-.12345");


[스펙]

-JavaScript 스펙에 포함
RegExp Spec.
ECMA-262 표준 ECMAScript Language Specification
ES3 , ES5 형태의 약칭 사용
ES6 부터 ES2015 형태 사용

-강좌 기준 : ES5.1

-C++ 11
javascript 정규 표현식 채택
C++11 RegExp



[3대 요소]

-문자열을 대상으로
"abcd", "ABCD" , "문자열"

-조건을 지정하여
/^/ ,/$/ , /+?/


-실행
검색, 치환 , 검사(test)
6개 method 사용
match() , replace(), search(), split()  //String 오브젝트에서 지원
exec() , test() //RegExp 오브젝트에서 지원


[패턴]

-패턴(pattern)
대상 문자열을 검색하기 위한 검색 기준
정규 표현식 패턴이라고 하며 약칭으로 패턴

-작성 방법
//사이에 패턴(검색 기준)작성
"안녕하세요".match(/안녕/);

-패턴 형태
1.검색 대상을 문자열 값으로 검삭하는 패턴
-"안녕하세요".match(/안녕/);
2.패텬 문자로 검색하는 패턴
^,$,*,?,|,() 등
"안녕하세요".match(/^안녕/);


[매치]

-매치(match)
대상 문자열에 패턴을 적용하는 것
대상 문자열을 매치 대상이라고 함

-패턴 매치
매치 대상에 패턴을 매치(적용)하는 것
패턴이 매치되었다, 되지 않았다라고 부름

-패턴 매치 실행
매치 대상을 패턴으로 검색, 치환, 검사하는것
match(), replace()와 같은 6개의 메소드가 담당
패턴 매치 실행을 줄여서 매치라고 부름


[작성 방법]

-정규 표현식 작성 방법
1.매치 대상 문자열을 메소드 앞에 작성하고
메소드의 파라미터에 패턴을 작성
"sports".match(/sp/)

2.패턴을 앞에 작성하고
메소드의 파라미터에 대상 문자열 작성
/^\-?\d+?/.test("12345");

3.new 연산자로 RegExp 인스턴스를 생성하고
메소드를 혀출하는 방법
var reg = new RegExp(/w/);
reg.exec("123");


[파라미터에 패턴 작성]

구분  /   요소   / 개요

"sports"   /  대상 / 매치 대상
.    /  연결자   / 매치 대상과 메소드 연결
match() / 메소드 / 매치 대상에 패턴을 매치하고 결과 반환
/sp/    / 패텬 / 매치 기준


-메소드의 파라미터에 패턴 작성
매치 대상 "sports" 를 match() 앞에 작성하고
match()의 파라미터에 패턴(/sp/) 작성
"sports".macth(/sp/);

-변수에 패턴 할당
pattern 변수에 패턴을 할당하고
var pattern = /sp/;
match()의 파리너테 변수 이름을 작성
"sports".match(pattern);

[RegExp 인스턴스 사용]

-RegExp 인스턴스 사용
1.new 연산자로 RegExp 인스턴스 생성
파라미터에 패턴 작성
var regexp = new RegExp("sp");

2.인스턴스를 사용하여 메소드 호출
메소드의 파라미터에 매치 대상 작성
var result = regexp.test("sports");


[텍스트 문자열 매치]
-텍스트 문자열 
0개 이상의 문자로 구성된 문자열
"A"도 문자열이고 "ABC"도 문자열
텍스트 문자열의 약칭 : 문자열

-매치 방법
매치 대상을 문자열로 매치
"sports".match(/sp/);
매치 대상 "sports"에 sp가 있으므로 매치가 되며
매치된 문자열을 [배열]로 반환

-읽는 방법
매치대상에 s가 있고 이어서 p가 있으면 매치된다.


[플래그]

플래그 / 명칭 / 기능 개요

i    /  ignore case / 영문 대소문자를 구분하지 않음. 매치된 첫 문자열 반환
g    /  global   / 반복하여 패턴을 매치하고 매치된 모든 문자열을 배열로 반환
m    /  multilne / 매치 대상에 줄 바꿈이 있더라도 전체 검색
u    /  unicode / ES6
y    /  sticky  / ES6

-플래그(flag) 작성 방법
"SPORTS".match(/sp/i);
패턴 다음에 소문자로 작성
i,ig,igm과 같이 다수 작성 가능
mgi와 같이 순서를 바꾸어도 됨

new RegExp("sp","i");
생성자 함수의 두 번째 파라미터에 플래그 작성

-대문자로 플래그 작성
브라우저에 따라 에러가 나거나 null 반환


[i 플래그]

-영문 대소문자 무시
대소문자를 구문 하지 않음
"SPORTS".match(/s/i); 

대문자가 매치되면 대문자로  , 소문자가 매치되면 소문자로 반환합니다


[g 플래그]
-반복 매치
일반적으로 패턴이 매치되면 더 이상 매치하지 않지만
플래그 g는 :
반복하여 문자열을 매치하고 , 매치된 모든 문자열을 반환
"SPORTS".match(/s/ig);

플래그 g가 패턴을 매치하는 것은 아님
패턴으로 매치하고, 매치를 반복 수행

[m 플래그]
-멀티라인 매치
일반적으로 매치 대상을 여러 줄에 작성하더라도 한 줄만 매치하면
m 플래그는:
모든 줄을 매치
줄 분리 문자를 줄 분리로 인식하지 않고 일반 문자로 인식



[대체]

-패턴문자 : |
대체(alternative) |(쉬프트+역슬래시:window 기준)
"34_56".match(/34|56/);

-기능
대체(|)의 왼쪽과 오른쪽을 모두 매치하여 관리 영역에 저장
모두 매치하는 것을 정규 표현식의 최적화 메커니즘이라고 함

왼쪽 인덱스 값과 오른쪽 인덱스 값을 비교
같거나 작으면 왼쪽 매체 결과를 반환
아니면 오른쪽 매치 결과를 반환

인덱스는 매치 대상 기준
대체(|)작성 순서에 따라 값이 반환되는 것이 아님
매치되지 않으면 비교하지 않음


[앞뒤 문자 매치]

-패턴 문자 : .(dot)

-기능
점(.) 위치에 문자가 있어야 하며
점의 앞과 뒤에 지정한 문자열을 매치
spports.match(/.s/);
단 , 줄 분리 문자는 제외
문자열 지정이 필수가 아니므로
점(.) 앞 또는 뒤에 면자열 작성 생략 가능


[공백문자]

Unicode / 명칭 / 영어 명칭 / 형태 / 매치 문자
\u0009 /  수평 탭 / Horizontal Tab / \t
\u000B /  수직 탭 / Vertical Tab
\u000C /  폭 넘김  / From Feed /
\u0020 /  공백     / Space
\u00A0 /  자동 줄 바굼 방지 / 

-white-space
문자지이만 보이지 않는 문자
토큰(token)을 구분할 때 사용
토큰 : 화이트 스페이스 양 옆의 문자 또는 단어

-문자 이스케이프(Charachter Escape)
역슬래시에 이어 문자 값 지정
\u0061(유니코드),\x61(16진수) , \t(제어문자)등에 사용
웹 페이지에 역슬래시가 \ 형태로 표시됨
역슬래시를 표시하려면 : 
HTML은 하나 작성, JS는 연속해서 두 개 작성

[줄 분리자]

-라인 단위 분리
라인 단위로 줄을 분리
LF : 줄을 바꾸고 바뀐 줄의 현재 위치로 이동
CR : 줄을 바꾸고 바뀐 줄의 처음으로 이동
일반적으로 프로그램에서 줄을 바꿀 떄는 LF와 CR을 같이 작성


[처음부터 매치]

-패턴문자 : ^(caret)

-기능
매치 대상의 처음부터 매치
"12_12".match(/^12/);
패턴에 지정한 문자가 
매치 대상의 청므부터 모두 같아야 성공

문자가 매치 대상의 중간에 있더라도 매치 실패

[끝에 매치]

-패턴 문자: $

[63개 문자 매치]

-패턴 문자 : \B

-기능
63개 문자에 매치
영문 대문자(26), 소문자(26) , 숫자(10), 언더바(_)
"12A".match(/12\B/);

패턴에 "문자열\B" 형태로 작성했을때
문자열이 매치되고 63개 문자가 매치되어야 매치로 처리
\B로 매치된 문자열은 반환하지 않음


[단어 경계]

-패턴 문자 : \b

-기능 
63개 이외 문자에 매치
영문 대문자(26), 소문자(26) , 숫자(10) , 언더바(_) 제외
"A12".match(/12\b/);

패턴에 "문자열\b" 형태로 작성했을때

[메소드 인식]

-코드 형태
"12".match(/12/) : 문자열.메소드(패턴)
/12/.exec("12") : 패턴.메소드(문자열)

-값 타입에 따라 오브젝트 생성
오브젝트를 알아야 오브젝트에 속한 메소드 호출
메소드 앞의 값 타입에 따라 오브젝트를 생성하고
오브젝트에 속한 메소드 호출

문자열 타입 : String 오브젝트
패턴 타입 : RegExp

[String 과 RegExp]

-오브젝트 처리 범위
String 오브젝트 : 문자열
RegExp 오브젝트 : 정규 표현식

-패턴 매치 메커니즘
1.String 오브젝트에는 정규 표현식 기능이 없으므로
2.String 오브젝트에서 RegExp 인스턴스 생성
-패턴을 파라미터로 넘겨줌
3.RegExp 인스턴스의 메소드를 호출
-매치 대상 문자열을 파라미터로 넘겨줌
4.RegExp 인스턴스에서 패턴 매치 결과를 반환
5.String 인스턴스에서 반환된 값 정리
-예 : replace()이면 값 대체 처리
반환할 형태(값,배열,null 등) 등을 정리


[match()]

data / string / 매치 대상
파라미터 / RegExp / 패턴, 문자열
반환 / Array / 매치 결과 , 매치되지 않음 null
반환 / property / ?index:매치된 인덱스 , g 플래그는 반환안함


[search()]
-개요
매치된 첫 문자의 인덱스 반환
"34_12_56".search(/12/);
다수가 매치되더라도 첫 번째 인덱스만 반환
매치되지 않으면 -1 반환
매치 대상에 문자열의 존재 여부를 체크할 때에도 사용

-indexOf() : 시작 위치 지정 가능
-search() : 다양한 조건의 패턴 지정 가능


[split()]

-개요
매치 결과를 분리하여 배열로 반환
"12_34_56".split(/_/);

첫 번째 파라미터의 구분자로 매치 대상을 분리
구분자는 반환하지 않음
구분자 앞 또는 뒤에 문자열이 없으면 빈 엘리먼트 반환
파라미터에 빈 문자열을 지정하면 매치 대상을 문자 단위로 분리

//소괄호 안에 넣으면 분리자를 포함한다!!
var result = "12A34A56".split(/(A)/);
js.log(result);



[replace()]

-개요
매치된 문자열을 지정한 값으로 변경
"12_34_12".replace("12",77);

두 번째 파라미터에 문자열 , 패턴 , 함수 지정 가능


[test()]

-개요
패턴을 매치 대상에 매치하여 매치 여부를 반환
하나라도 매치되면 true, 매치되지 않으면 false 반환
test() 앞에 패턴 작성

[exec()]

-매치와 비슷한 기능이지만
g 플래그를 사용해도 같은 문자 하나만 배열로 반환

var result = /12/.exec("12_34_12");
js.log(result);
js.log(result.index);
js.log(result.input);

result = /12/g.exec("12_34_12");
js.log(result);

[수량자 패턴]

분류   / 패턴 문자  / 형태   / 개요

욕심 많은 매치 / + / "aaac".macth(/a+/); / 하나 이상 매치
욕심 많은 매치 / * / "aaac".macth(/K*/); / 없거나 하나 이상 매치
욕심 많은 매치 / ? / "aaac".macth(/ascS?*/); / 없거나 하나만 매치

숫자로 매치 범위 지정 / "aaac".match(/a{2}/); / 수에 매치
숫자로 매치 범위 지정 / "aaac".match(/a{1,}/); / 수에 매치
숫자로 매치 범위 지정 / "aaac".match(/a{2,4}/); / 수에 매치

-수량(quantifier)
매치되는 수와 관련된 패턴 문자
욕심 많은 매치, 숫자로 매치 범위 지정, 욕심 없는 매치로 분류

[하나 이상 매치]

-패턴 문자 : + 
욕심 많은(greedy) 매치로 가능한 최대로 매치

-기능
하나 이상 매치
"aaac".match(/a+/);

a+와 같이 매치할 문자를 +앞에 작성
+앞에 작성한 문자가 반드시 매치되어야 하고
매치된 문자가 연속되어 있으면 모두 매치
매치된 문자를 하나의 배열 엘리먼트로 묶어서 반환
{1,}기능과 같음


[모든 문자 매치]

-패턴 문자 : .+
패턴 문자 .과 +를 조합한 것

-기능
패턴 문자 +는 최대로 매치하려는 특성을 갖고 있으며
dot(.)은 .위치에 아무 문자가 있으면 매치하므로
결국 문자가 있으면 계속 매치하게 되어 모든 문자열을 매치
"aaac".match(/.+/);


[정규 표현식 최적화]
-전체 분석
무조건 왼쪽에서 오른쪽으로 매치하지 않고
매치 대상과 패턴 전체를 분석한 후 매치를 행함

-"abcAB".match(/.+AB/);
1.매치 결과 :[abcAB]
2.패턴 순서가 .+이므로 왼쪽부터 매치하면 abcAB를 매치를 행함
더이상 매치할 문자열이 없으므로
패턴 마지막의 AB를 매치할수 없어
패턴 전체에서 보면 매치가 실패하게 됨

3,실패가 되는 것을 방지하기 위해
AB를 매치하고 나머지에 대해 .+패턴을 매치
이를 정규 표현식 최적화라고 함

[없거나 하나 이상 매치]

패턴 문자 : *
욕심 많은 매치로 간으한 최대로 매치

-기능
왼쪽에서 오른쪽으로 아울러 오른쪽에서 왼쪽으로 매치
"12A".match(/12C*/);
왼쪽부터 매치하면 12C가 매치되지 않아 매치 실패
*표 앞의 문자를 하나 이상 매치

따라서 *앞의 C가 매치되지 않아도
12가 매치되는지 



[없거나 하나만 매치]

-패턴 문자 : ?
욕심 많은 매치로 가능한 최대로 매치

-기능
?앞의 문자가 없어도 매치되고 있어도 매치로 처리
"123AAA".match(/123S?/);
123S로 매치하면 매치되지 않지만 123은 매치

모든 문자를 매치하지 않고 하나만 매치
"123AAA".match(/123A?/);


[욕심 많은 매치 매커니즘]

-뒤에서 부터 매치
욕심 많은 패턴 문자에 이어 문자열이 있을 때
뒤에서 부터 앞으로 올라가면서 매치
그래서 전체 매치가 성공하기 떄문

-"123ABCD".match(/.?AB/);
1.앞에서 부터 매치하면 .?가 모두 매치하므로
AB를 매치할 수 없어 매치 실패

2,패턴 전체가 매치되려면 반드시 AB가 매치되어야 함
따라서 우선 AB를 매치하면 123이 남음
그리고 .?를 사용하여 3을 매치
?가 하나만 매치하므로 3만 매치하고 매치를 종료
뒤에서 부터의 기준은 패턴의 마지막인 AB


[수에 매치]

-패턴 문자 : {숫자}

-기능
{}앞에 문자가 {}안의 수 만큼 매치되면 매치로 처리
"AAA".match(/A{2}/);
{2}앞의 A가 2개 매치되므로 매치로 처리


[수 이상에 매치]

-패턴 문자: {숫자,}

-기능
{}에 작성한 수 이상 매치하면 매치로 처리
"AAA".match(/A{2,}/)

[매치 구간 지정]

-패턴 문자 : {숫자,숫자}

-기능 
최소와 최대 구간에 매치되면 매치로 처리
{숫자,숫자}에서 첫 번째에 최소를 두 번째에 최대를 작성
"AAA".match(/A{1,3}/);

A가 한개에서 3개까지  매치되면 매치로 처리
최대로 매치된 문자열울 묶어서 배열로 처리



[한 번만 매치]

-패턴 문자 : +?
욕심 없는 매치로 가능한 최대로 적게 매치
이를 위해 왼쪽에서 오른쪽으로 매치

-기능
연속된 모든 문자를 매치하지 않고 한번만 매치
"AAAAAC".match(/AA+?/);
AA를 여러 번 매치할 수 있지만 한 번만 매치


[최소 매치]

-패턴 문자: *?

-기능
가능한 최소로 매치
왼쪽에서 오른쪽으로 매치
직전의 문자를 매치하지 않음
"ABCABC".match(/ABC*?/)

ABC가 매치되지만 *? 앞에 C가 있으므로 C는 매치하지 않음
따라서["AB"]가 반환 됨


[숫자 범위 무시]

-패턴 문자 : {숫자,숫자}?

-기능
하나만 적용하겟다!!


