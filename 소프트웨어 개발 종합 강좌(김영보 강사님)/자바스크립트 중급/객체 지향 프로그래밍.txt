[객체]

-객체의 기본 요소
행위(behavior) : 메소드로 표현
속성(attribute)
==자바스크립트는 속성보다 프로퍼티가 더 적절

-객체
독립적으로 존재하며
객체 자체에서 목적 달성

-객체 지향 프로그래밍
OOP : Object Oriented Programming
객체 중심으로 프로그래밍하는 방법 , 형태
개념은 비슷하지만 언어마다 구현 방법, 형태에 차이 있음


[클래스]

-클래스(Class)
객체의 행위와 속성을 선언하는 영역
텍스트 형태이므로
이를 사용하여 오브젝트로 생성해야 함

-자바스크립의 클래스

ES5까지 클래스가 없엇으나 ES6부터 사용
--개념은 비슷하지만 기본적으로 차이 있음

자바스크립트는 function 키워드를 만나면
--자동으로 Function 오브젝트 생성

new 연산자로 클래스를 오브젝트로 생성하는 것과는 차이 있음

--자바스크립트 Class는 C++등의 클래스와 다르다.


[OOP 주요 개념]

-주요 개념
추상화(Abstracion)
캡슐화(Encapsulation)
다형성(Polymorphism)
상속(Inheritance)

-추상화
추상화의 목적은 최적화
공통 개념을 하나로 정의하는 것부터 시작
정의하는 것에 중심을 두므로
추상화 class는 독립적으로 수형할 수도 있음


--공통분모가 있다면 상위로 빼서 사용한다!!
예 : 객체 발,다리에 같이 피다라는 메소드가 있다면 추상화 해서 올린다.

-자바사크립트에서 추상화
일반적으로 사용하지 않음
이유는 상속을 크게 사용하지 않기 때문


[캡슐화]

-캡슐화
객체의 메소드와 프로퍼티를 외부에 숨긴
처리 방법은 숨기고
--사용할 수 있는 메소드와 파라미터를 외부에 공개
관련 OOP 용어 : 정보 은닉(Information Hidding)

-자바스크립트의 캡슐화
함수 안의 함수를 직접 호출 불가
지역 변수 값은 외부에서 직접 접근 불가
sourcr가 오픈되는 것과 exe 파일과의 차이 있음


[다형성]

-다형성
파라미터 수, 파라미터 데이터 타입에 따라 메소드 존재
--메소드를 호출하면 파라미터에 맞는 메소드 호출
-OOP 용어 : 오버로딩(Overloading)

-자바스크립트의 다형성
파라미터 수와 데이터 타입에 영향을 받지 않음
메소드 이름이 같으면 나중에 작성한 것으로 대체 됨
!! 다형성 없음!!


[상속]

-상속
상속의 목적은 객체의 재사용
목적에 맞는 객체를 내 객체에 포함시키는 것
다중 상속
--java : 다중 상속 불가 , C# : 가능
-- 다중 상속은 논란의 여지가 있음

-자바스크립트의 상속
오브젝트{}와 오브젝트를 병합
함수의 prototype에 인스턴스 연결
다중 상속 불가
다수의 인스턴스가 연결된 형태 : Prototype Chain


[오브젝트 연결]
-연결 방법
오브젝트의 프로퍼티에 오브젝트 연결
완전한 형태의 상속은 아니지만
--오브젝트를 연결할 수는 있음

-연결한 오브젝트에 접근
오브젝트와 프로퍼티를 지정하여 접근


[오브젝트 병합]

-병합 방법
오브젝트와 오브젝트를 하나의 오브젝트로 병합
for~in 문으로 오브젝트를 읽어 병합할 오브젝트에 설정
이름이 같은 프로퍼티가 있으면 값이 대체


[상속 메커니즘]

-자바스크립트 상속 메커니즘
프로퍼티 값에 인스턴스를 연결
상속받은 것을 구분하기 위해
인스턴스에 __proto__를 연결하고
여기에 상속받은 인스턴스를 연결


[Object.create()]

-오브젝트 상속 구현
첫 번째 파라미터에 상속받을 오브젝트를 지정
두 번째 파라미터로 인스턴스를 생성하고
--첫 번째 파라미터의 오브젝트를 상속받음
두 번째 파라미터의 프로퍼티는 오브젝트 프로퍼티로 설정

-Function에 prototpye까지 작성하면  인스턴스로 상속가능

var baseball = {
		member : 123,
		setValue : function(param){
			this.member = param;
		}
};

var sports = Object.create(baseball,{
	member : {value : 456, writable : true},
	getValue : {
		value : function(){
			return this.member;
		}
	}
});

js.log(sports.getValue());
sports.setValue(789);
js.log(sports.getValue());


[프로토타입 체인]


-프로토타입 체인(prototype chain)?
Function 오브젝트의 prototype에
--new 연산자로 생성한 인스턴스를 연결할 형태
연속해서 prototype에 인스턴스를 연결할 수 있으므로
계층 구조로 형태로 만들수 있음


[검색 우선순위]

-this.property_name 형태로 검색하면
우선 서브 오브젝트에서 검색
--프로퍼티가 검색되면 종료
검색되지 않으면 슈퍼 오브젝트(__proto__)에서 검색
--그래도 검색되지 않으면 계속 올라가면서 검색
이 개념(형태)을 검색 우선순위라고 함

-prototype 형태
슈퍼와 서브 오브젝트 각각에 프로퍼티 존재
슈퍼 오브젝트의 프로퍼티가 서브 오브젝트를 대체하지 않음
인스턴스로 연결하고 검색 우선순위로 각각의 프로퍼티를 검색

-변수와 prototype의 차이
변수 : 함수 밖으로 나가 글로벌 오브젝트로 올라가면서 검색
prototype : this.prototype_name 형태로 검색
--상속받은 인스턴스로 올라가면서 검색하지만
--글로벌 오브젝트까지 올라가지 않고 상속받은 범위에서 검색

[슈퍼 오브젝트 접근]
-call()로 슈퍼 오브젝트 메소드 호출
슈퍼 오브젝트의 prototype에 연결된 메소드를 호출


