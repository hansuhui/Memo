[동등 연산자]

동등 연산자(Equals Operator)는 ==로 표기하며 ==를 기준으로 왼쪽 피연산자 값과
오른쪽 피연산자 값이 같으면 true를, 같지 않으면 false를 반환합니다. 자바스크립트는
다양한 조건에 따라 값을 반환하며 비교 기준을 정리하면 아래와 같습니다. 값을 반환하면
더 이상 비교하지 않습니다.

왼쪽 피연산자 값과 오른쪽 피연산자 값을 구합니다. 비교 기준은 왼쪽과 오른쪽 데이터타입이
같을 때와 다를 때로 나눌 수 있습니다.

[비교기준 : 왼쪽 데이터 타입과 오른쪽 데이터 타입이 같을 때 ]

1.데이터 타입이 Undefined 또는 Null이면 true를 반환합니다.
2.왼쪽이 Number 타입일 때
  A.둘 중에 하나라도 값이 NaN이면 false를 반환합니다.
  B.왼쪽 값과 오른쪽 같이 같은 숫자 값이면 true를 반환합니다.
  C.이상의 조건에 맞지 않으면 false를 반환합니다.

3.왼쪽 데이터 타입이 문자열일 때
  A. 왼쪽과 오른쪽 문자 수가 같으면서 같이 같으면 true를 반환하고
  B.아니면 false를 반환합니다.

4.왼쪽 데이터 타입이 Boolean일 때
 A.왼쪽과 오른쪽 모두 true또는 false 이면 true를 반환하고
 B. 아니면 false를 반환합니다.

5.왼쪽과 오른쪽 값이 같은 오브젝트를 참조하면 true를 ,아니면 false를 반환합니다.



[비교기준 : 왼쪽 데이터 타입과 오른쪽 데이터 타입이 다를 때 ]

6.왼쪽 값이 null이면서 오른쪽 값이 undefined이면 true를 반환합니다.

7.왼쪽 값이 undefuned이면서 오른쪽 값이 null이면 true를 반환합니다.

8.왼쪽이 숫자 타입이고 오른쪽이 문자열 타입일 때
 A.오른쪽을 숫자 값으로 변환하여 (왼쪽 값 == 변환 값)의 비교 결과를 반환합니다.

9.왼쪽이 문자열 타입이고 오른쪽이 숫자 타입일 때
 A.왼쪽을 숫자 값으로 변환하여 (변환 값==오른쪽 값)의 비교 결과를 반환합니다.

10.왼쪽이 불린 타입이면 숫자 값으로 변환하고 (변환값 == 오른쪽)의 비교 결과를 반환합니다.

11.오른쪽이 불린 타입이면 숫자값으로 변환하고 (왼쪽값 == 변환값)의 비교 결과를 반환합니다.

12.위 조건에 일치하지 않으면 false를 반환합니다.


예제

1 == '1' / true

var one;

one == undefined / true

one == null / true

'abc' == 'abc ' / false


-false 비교

프로그램에서 true,false를 비교할 때 false 비교는 특히 주의할 점이 있습니다.

false == '0' / true   - 문자를 숫자로 변환 / 블린도 숫자로 변환

false == "" / true -  - 공백은 숫자 0에 해당함


[부등 연산자]

!= 값이 다름을 표시

[일치 연산자]

일치 연산자 (Strict Equals Operator)는 ===로 표기하며 == 연산자가 값을 비교하는 반면
===연산자는 값과 데이터 타입을 함께 비교합니다. 예를 들어 숫자 0과 문자열 "0"를 비교
할 때 == 연산자는 true를 반환하고 , ===연산자는 false를 반환합니다. 자바스크립트 비교
기준을 정리하면 아래와 같습니다. 값을 반환하면 더 이상 비교하지 않습니다.

[비교 기준]

1.왼쪽 피연산자 값과 오른쪽 피연산자 값을 구합니다.

2.데이터 타입이 다르면 false를 반환합니다.
  {설명}따라서 아래는 데이터 타입이 같을 때만 비교합니다.

3.왼쪽 데이터 타입이 Undefined 또는 Null이면 true를 반환합니다.

4.왼쪽 데이터 타입 Number일 때
  A.왼쪽 값 또는 오른쪽 같이 NaN이면 false를 반환합니다.
  B.왼쪽 값과 오른쪽 값이 같은 숫자 값이면 true를 반합합니다.
  C.이상의 조건에 맞지 않으면 false를 반환합니다.

5.왼쪽 데이터 타입이 문자열일 때
  A.왼쪽과 오른쪽 문자 수가 같으면서 같이 같으면 true를 반환하고
  B.아니면 false를 반환합니다.

6.왼쪽 데이터 타입이 Boolean일 때
  A.왼쪽과 오른쪽 값이 모두 true 또는 false이면 true를 반환하고
  B.아니면 false를 반환합니다.

7.왼쪽과 오른쪽 값이 같은 오브젝트를 참조하면 true를 아니면 false를 반환합니다.

[예제]

1=== '1' / false

1 === 1  / true

var one;

one === null / false

true === 1 / false


[불일치 연산자]

불일치 연산자(Strict Does-not-equal Operator)는 !==와 같이 ==연잔자 앞에 느낌표(!)를 
작성하며 ===연산자 비교 결과의 반대 값을 반환합니다. ===연산자의 결과가 true이면 false를
반환합니다. 다른 비교 기준은 앞서 살펴보았던 ===연산자와 같습니다.

[논리 OR 연산자]

바이너리 논리 연산자(Binary Logical Operators)에 논리 OR 연산자과 논리 AND 연산자가 있으며
이 절에서는 논리 OR 연산자를 살펴보고 다음 절에서 논리 AND 연산자를 살펴봅니다.

논리 OR 연산자(Logical OR Operator)는 ||로 표기합니다. 왼쪽 피연산자를 평가하여 값을 구하고 값을
불린 값으로 변환합니다. 변환한 불린 값이 true이면 평가한 값을 반환합니다.
false이면 오른쪽 피연산자로가 했던 처리를 반복합니다. 더이상 오른쪽에 피연자가 없으면
평가한 값을 반환합니다. [표 5-9]는 평가한 값을 불린 값으로 변환하여 반환되는 값입니다.
값이 숫자로 0이거나 빈 문자열이면 false가 반환됩니다.

[표 5-9]불린 값 변환

데이터 타입 / 결과 값
Undefined  / false
Null / false
Bollean / 변환하지 않고 그대로 반환
Number / 0 또는 NaN이면 false , 아니면 true
String / 빈 문자열이면 false ,  아니면 true
Object / ture


[조건(?:) 연산자]

조건 연산자(Conditional Operator)는 (exp ? first : second)와 같이 물음표 (?)와 콜론(:)을
사용해서 조건을 비교하고 조건에 해당하는 표현식을 평가하여 값을 반환합니다. 삼항 연산자라고도
부릅니다. exp 위치에 불린 변환 값이 true이면 first위치의 표현식을 평가하여 값을 반환하고 false이면
second위치의 표현식을 평가하여 값을 반환합니다. exp 위치에 불린 값 변환 기준은 OR 연산자와 같습니다.


[<< 연산자]

비트 연산자의 ES5 스펙 명칭은 비트 이동 연산자(Bitwise Shift Operator)이지만 일반적으로
비트 연산자라고 부르므로 이 책에서도 비트 연산자로 표기합니다. 비트 연산자에는
<<, >> , >>> 연산자가 있습니다.

비트는 0과 1로 구성되므로 2진수 연산을 하며 자바스크립트는 32비트 정수 연산을 합니다.
32번째 비트에 사인(sign) 부호가 설정되며 이 값이 0이면 양수 값을 , 1이면 음수 값을 나타냅니다.
비트 연산을 하는 가장 큰 장점은 연산 속도가 빠르다는 점입니다.

왼쪽 이동 연산자 (Left Shit Operator)는 << 로 표기하며 << 를 기준으로 왼쪽 값을 오른쪽에
지정한 수만큼 이동시킵니다. 왼쪽으로 이동하면 가장 왼쪽 비트는 오른쪽에서 이동한 비트 값으로
대체되며 이동한 오른쪽 비트에는 0이 설정됩니다. 이는 지정한 수만큼 2를 곱한것과 같습니다.

var value = 3; / 0011

value << 1; / 6(0110)

value << 2; / 12(1100)


[>> 연산자]

사인 부호 포함 오른쪽 이동 연산자(Signed Right Operator)는 >> 표기하며 >> 를
기준으로 왼쪽 값을 오른쪽에서 지정한 수만큼 오른쪽으로 이동시킵니다. 오론쪽으로 이동하면
가장 오른쪽 비트는 왼쪽에서 이동한 비트 값으로 대체되며 이동한 왼쪽비트에는 0이 설정됩니다.
단 양수/임수를 나타내는 32번째 비트의 값은 바뀌지 않습니다. 이는 지정한 수만큼 2로
나누고 소수 이하를 버린 정숫값과 같습니다.

var value = 10 (1010);

value >> 1; / 5(0101)

value >> 2; / 2(0010)



[2의 보수 표현법]

>>연산자로 음수를 처리하기 위해서는 우선 알고리즘(algorism)을 이해할 필요가 있습니다.
음수로 처리하는 방법 중에 2의 보수 표현법(two's complement)이 있습니다. 이는 각
비트 값을 반대 값으로 바꾸고 1을 더하는 방법입니다. 즉 0은 1로 , 1은 0으로 바꾸고 1을 더합니다.

ES5 스펙에 2의 보수 표현법을 사용하라고 기술되어 있지는 않습니다. 최종값을 구하는 
프로세스(process)가 개념적으로 작성되어 있으며 구현 방법은 기술되어 있지 않습니다.
구현을 자바스크립트 컴파일러 개발사에 일임한 것입니다. 그래서 결과는 같지만
브라우저 마다 성능에 차이가 있습니다.

-2의 보수 표현법

10진수 10을 2진수로 표현하면 아래 형태로 비트값이 설정됩니다.

00001010 (10)

이 형태에서 각 비트를 반대 값으로 바꾸면 아래 모습이 됩니다.

11110101 

여기에 1을 더하면 아래 모습이 됩니다.

11110110 (10의 2의 보수 표현)

[>> 연산자 음수 처리]

var value = -10; (11110110)

value >> 1

1비트 오른쪽으로 이동

11111011

여기서 1을 빼면 아래 모습이 됩니다.

11111010 (-5)

여기서 0과 1을 바꾸면

00000101 이되고 음수 부호를 붙이면 -5가 됩니다.


value >> 2

11111101

여기서 1을 빼면 

11111100

0을 1로, 1을 0으로 바꾸면 아래 모습이 되며 음수 부호를 설정하면 -3이 됩니다.


[>>> 연산자]

사인 부호 없는 오른쪽 이동 연산자(Unsigned Right Shift Operator)는 >>>로 표기하며
>>> 를 기준으로 왼쪽 값을 오른쪽에 지정한 수만큼 오른쪽으로 이동시킵니다.
여기까지는 >> 연산자와 처리 방법은 같습니다. >>>연산자는 가장 왼쪽에 양수, 음수를 나타내는
사인 부호도 이동된다는 점이 다릅니다.

값이 음수이면 가장 왼쪽의 사인 부호 값이 1입니다. 이 상태에서 오른쪽으로 이동하면 1이
오른쪽으로 이동하게 되어 음수를 나타내는 부호가 아닌 값이 됩니다. 사인 부호 비트에는
0이 설정됩니다.

var value = -1;
value >>> 1 / 2,147,483,647

2의 31승 값이 2,147,483,648 이므로 이 값에서 1을 뺀 값입니다.

value >>> 2 / 1,073,741,823

2의 30승 값이 1,073,741,824이므로 이 값에서 1을 뺀 값입니다.


[비트 OR 연산자]

바이너리 비트 연산자(Binary Bitwise Operators)에는 |,&,^ 연산자가 있으며 2항 연산자로
비트 단위로 연산합니다.

비트 OR 연산자(Bitwise OR Operator)는 |로 표기합니다. |를 기준으로 왼쪽 피연산자 값과
오른쪽 피연산자 값을 2진수 비트로 변환하여 연산합니다. 둘 중에 하나라도 비트 값이 1이면
1로 처리합니다.

2 | 5 / 7

아래에서 2진수로 2가 첫 번째 모습이고 5가 두 번째 모습입니다.

2진수 2

00000010

2진수 5

00000101

첫 번째와 두 번째 형태에서 하나라도 1이 있으면 1을 설정하므로 
아래 형태가 되어 7이 출력되었습니다.

2 | 5 결과

00000111 (OR게이트 인듯 !!! 두개의 비교 값중 1이라면 값을 1로 만든다!!)


[비트 AND 연산자]

비트 AND 연산자 (Bitwise AND Operator)는 &로 표기합니다. &를 기준으로
왼쪽 피연산자 값과 오른쪽 피연산자 값을 2진수 비트로 변환하여 연산합니다.
비트 값이 모두 1이면 1로 처리하고 그렇지 않으면 0으로 처리합니다.


2 & 5 / 0

아래에서 2진수로 2가 첫 번째 모습이고 5가 두번째 모습입니다.

2진수 2

00000010

2진수 5

00000101

첫번째와 두 번째에서 같은 위치의 값이 모두 1인 것이 하나도
없으므로 아래 형태가 되어 0이 출력되었습니다

00000000 (AND게이트 인듯 !!! 비교 값이 둘다 true일 경우에만 true이다)


[비트 XOR 연산자]

비트 XOR 연산자(Bitwise XOR Operator)는 ^로 표기합니다. ^를 기준으로 왼쪽 
피연산자 값과 오른쪽 피연산자 값을 2진수 비트로 변환하여 연산합니다.
같은 위치의 비트 값이 같으면 0이 되고 하나만 1이면 1이 됩니다.

3 ^ 5 / 6

2진수 3

00000011

2진수 5

00000101

첫 번째와 두 번째에서 가장 오른쪽 비트만 값이 같으므로 0으로 설정됩니다.
두 번째와 세 번째 비트는 값이 다르므로 1로 설정되어 6이 출력

3 ^ 5 결과

00000110 (XOR 게이트!!! 서로 다르면 1 서로 같으면 0)


[프로퍼티 악세스 연산자]

프로퍼티 악세스(Property Access)는 오브젝트{name : value} 형태에서 프로퍼티 값을
반환 받는 처리를 의미하며 연산자(Operator)에는 두 가지 표기법이 있습니다.
market['book']과 같이 대괄호 안에 프로퍼티 이름을 문자열로 작성하는 표기법과
market.book과 같이 점(.)으로 연결하여 프로퍼티 이름을 작성하는 표기법이 있습니다.

var sports = {soccer : '90분', baseball : '9명'};
sports['baseball']; / 9명
sports.soccer; / 90분


[콤마 연산자(,)]

콤마 연산자(Comma Operator)는 콤마(,)로 표기합니다. 콤마(,)를 기준으로 왼쪽 표현식과
오른쪽 표현식을 수행하고 각 표현식에서 피연산자 값을 반환합니다.

var sports = 100;
var book = 200;

var sports = 100, book = 200;


[그룹핑 연산자]

그룹핑 연산자(Grouping Operator)는 소괄로 ()로 표기합니다. ()안에 표현식을 먼저 평가하고
결과를 반환합니다. ()연산자 안에 ()연산자가 있으면 안의 ()연산자를 먼저 평가합니다.

5/(2+3) / 1

[연산자 우선순위]

1.() - 그룹핑 연산자
2. 점.[],new() / 프로퍼티 악세스 연산자
3. () - 함수 호출
4.++,-- 
5.!,~,+,-,typeof, void , delete
6. *,/,%
7. +,-
8.<< ,>> ,>>>
9 < ,<= , > ,>= , in , instanceof
10. == , != , === , !==
11. &
12. ^
13. | 
14. &&
15. ||
16. ?: - 삼항 연산자
17 , =,+=,-=,*=,/=,%=,<<= , >>=,>>>=,&=,^= , !=
18 . (,) - 콤마 연산자


=============================================문장============================================

[블럭]

문장이 연속되어 글이 되듯이 자바스크립트 프로그램도 문장(Statement)이 연속되 형태입니다.
문법에 맞추어 글을 써야 하듯이 자바스크립트 프로그램도 문법에 맞추어 작성해야 합니다.
주변 내용에 따라 "문장" 또는 "문"으로 표기하지만 같은 의미입니다.

블럭(Block)은 중괄호 {}로 표기하며 블록 안에 작성된 문장을 하나의 실행 단위로 묶습니다.


형태 {문장 리스트 (옵션)}

var a,b;

if(a==b){
var sports = '스포츠';
var swim = '수영';
}


[빈 문장]

빈 문장(Empty Statement)은 문장에 자바스크립트 코드를 작성하지 않고
세미콜론(;)만 작성한 형태를 나타냅니다. var sports;와 같이 세미콜론 앞에
문장이 있을 때는 빈 문장이라고 하지 않고 세미콜론이라고 부르며 이때 
세미콜론은 문장을 완료시키는 역할을 합니다.

형태 ;


[while]

while문은 (표현식)을 평가한 불린 변환 값이 false가 될 떄까지 문장을 반복하여 실행합니다.
불린 변환 값이 true일 때 문장을 수행합니다.

형태 while(표현식) {문장}

표현식을 평가하고 결과를 불린 값으로 변환합니다. 불린 변환 값이 ture이면 문장을 실행하고
false이면 실행하지 않습니다. 불린 변환 값이 계속 true이면 무한대로 반복하게 되므로 false가
되도록 해야 합니다

var k =0;

while(k < 3){
  k= k+1;
}


[do-while]

do-while 문은 먼저 do 문장을 수행한 후 (표현식)을 평가합니다. 평가한 불린 변환 값이
true이면 false가 될 떄까지 do 문장을 반복하여 실행합니다, 평가한 불린 변환 값이 false
이면 while 안의 문장을 수행합니다.

형태 do {문장} while (표현식);

var k = 0;

do{
  k= k+1;
alert('do');
}while(k<3)
=== 따로
{
alert('while');
}

while 블럭엔 걸리지 않고 do 블럭에만 걸린다.
그리고 결과가 false가 되면 while를 창을 띄운다

[for]

for문은 표현식 평가 결과가 true인 동안 문장을 반복 실행합니다.

for(var 사용 옵션;표현식 옵션;증감 옵션){문장}
for(초깃값 옵션;표현식 옵션;증감 옵션){문장}


for문 예제

for(var k=0,value=0;k<3;k++){
 value += 20;
}


-세 번째의 증감 표현식 생략

for(var k = 0; k < 3 ){
문장
k= k+1;
}


-첫번째, 세번째 표현식 생력

var k =0;

for(;k<3;){
 k=k+1;
}


-두번째 , 세번째 표현식 생략

for(var k=0; ; ){

	k += 1;
	if(k > 2){
	   break;
	}
    }




-모두 생략
var k = 0;

    for(;;){
	if(k === 2){ break;}
	 k+= 1;
     }



-문장을 사용하지 않음

for(var k = 0; k <2 ; alert(k),k++);



-세미콜론 자동 삽입

for(var k =1 ; k<3 ; alert(k),k++)
alert('for 문장:'+k)
alert('다른문장'+k);


결과
for 문장 1
1
for 문장  2
2
다른문장 3


[label]

label문은 break 문 , continue 문에서 반복을 벗어날 때 연결용으로 사용합니다.
break문 , continue 문에서 레이블을 사용하지 않아도 됩니다.

형태 / 식별자 : 문장

식별자(identifier)는 식별할 수 있는 이름을 의미하며 유일한 이름을 사용합니다.
자바스크립트에서 사용하는 키워드, 예약어를 제외한 이름을 사용할 수 있습니다.
문장을 생략할 수 있지만, 콜론(:)은 작성해야 합니다. label 문의 예제는 break 문과
continue문에서 같이 다룹니다.



[break]

break 문은 for, for-in , while , do-while, swich 문에서 실행을 종료합니다.

형태
break;
break  식별자;

실행을 종료하므로 break 문 아래에 작성한 문장이 실행되지 않습니다.
식별자를 작성하면 식별자로 분기합니다. break와 식별자를 한 줄에 작성해야 하며
세미콜론을 작성해야 합니다.

var k= 0 , m=0;

while(k<1){
m = m + 1;
if(m===3){
   break;
  }
}



break 문을 설명하기 위해 의도적으로 작성한 코드입니다.
break; 문을 작성하지 않으면 k 변수값을 증가시키지 않으므로 무한 반복을 하게 됩니다.
break 문은 반복을 강제로 종료시키고 반복 문 밖의 다음 문장으로 이동합니다.


var m=0, value = 0;
start:
for(var k=0;k<4;k++){
 m=0;
for(;m<2;m++){
if(value ===2){break start;}
value += 1;
 }
}
alert('end');
결과 
1. k : 0 , m = 0 , value = 1
2. k : 1 , m = 2 , value = 2
3. end

위 코드의 특징은 앞부분에 "start:"가 작성되어 있으며 가운데 fro 문에 break start;가 
작성된 점입니다.

for(var k=0;k<4;k++){} 문장은 4회 반복하게 되므로 4번 실행 해야 하지만
for(;m<2;m++){}에서 break; 문은 해당 for문을 종료 할뿐 밖의 for문을 종료하지 않습니다.
그런데 두번만 출력되었습니다.

두 번 출력된 것은 break 다음에 식별자(start)를 작성했기 때문입니다.
break start;를 만나면 start:로 분기합니다. 그래서 밖의 for이 종료된것입니다.


-break : 식별자 형태

var value = 0;

outLabel :{
for(var k=0;k>5 ;k++){
	alert(value);
	if(k=== 1){break outLabel;}
	value = value +1;
	}
	alert('end')
}

결과 0, 1, end

[continue]

continue 문은 for, for-in, while , do-while 문에서 반복문의 처음으로 이동합니다.

형태 
continue;
continue 식별자;

continue 문 위치에서 반복문의 처음으로 이동하므로 continue 문 아래에 작성된 문장이 실행되지 않습니다.
식별자를 작성하면 식별자 위치로 분기합니다. continue와 식별자를 한 줄에 작성하고 세미콜론을 
작성합니다. 

for 문을 다섯 번 반복한다고 할 때 , 세 번째 반복에서 break문을 만나면 세번만 반복하지만
,continue 문은 다섯 번을 반복합니다.

for(var k =0; k < 5 ; k++){
	if(k===2 || k===3){
	continue;
	}
	alert(k);
}

결과
0,1,4

for문을 5회 반복하므로 결과가 다섯 번 출력이 되어야 하지만 continue; 문을 만나게 되어
아래 작성된 문장을 수행하지 않고 블럭의 첫 번째 문장을 실행합니다. 그래서
2와 3이 출력 되지 않았습니다.



[return]

return 문은 함수(function) 에서 사용하며 return 문의 표현식 평가 결과를 반환합니다.

형태 
return;
return 표현식;

return 문을 만나면 함수가 종료되며 함수를 호출한 문장으로 표현식 평가 결과를 
갖고 돌아갑니다. return 다음에 표현식을 작성하지 않으면 undefined를 반환합니다.

function amount(){
return 100+200;
}

var result = amount();
alert(result);

결과 : 300


아래는 함수 호출과 return 문으로 값을 반환하는 개념적인 시나리오입니다.
함수를 아직 다루지 않았으므로 return 문 중심으로 살펴봅니다.

함수 호출, 실행 return 문

1.자바스크립트 엔진이 amount()를 만나면 amount함수를 호출합니다.
{코드}var result = amount(0;
2. 첫 번째 줄에 작성한 amount 함수가 실행됩니다.
3. 자바스크립트 엔진이 함수 블록{} 안으로 이동합니다.
4.return문을 만나게 됩니다.
{코드} 100+200;
5.return 다음의 표현식을 먼저 평가하며 300이 됩니다.
6. return 300;을 실행합니다.
7. 호출했던 함수로 123을 갖고 돌아갑니다.
8.갖고 돌아온 값을 result 변수에 할당합니다.


[for-in]

for-in 문은 오브젝트(Object)를 열거하면서 문장을 실행합니다.
열거란 오브젝트 형태의 반복을 의미합니다.

형태
for(var 변수 in 오브젝트){문장;}
for(표현식 in 오브젝트){문장;}

오브젝트란 {name:value} 형태를 의미합니다. ES5 스펙에서 for-in 형태로 표기하고
있으므로 이 책에서도 for-in으로 표기합니다. for-in 문으로 
반복하는 것을 for-in 루프(Loop)라고 부릅니다.

var sports = {soccer:11 , basketball : 5};

for(var pty in sports){
 alert('name :' +pty+ ' value: ' sports[pty]);
}

결과
name : soccer , value : 11
name : basketball , value : 5



sports 오브젝트의 프로퍼티 이름과 값을 조합하여 출력을 하였습니다.
오브젝트 프로퍼티의 출력 과장을 단계별로 살펴봅니다.

1.처음 한번만 변수(pty)를 선언합니다.
{코드}for(var pty in sports)
{설명}한 번만 선언하므로 for-in문 안에서 변수를 선언할 수 있습니다.

2.for-in 문의 sports를 평가하고 값을 구합니다.
{코드} for(var pty in sports)
{설명}평가 목적은 구한 값의 오브젝트 여부를 체크하기 위해서입니다.

3.구한 값이 null또는 undefined이면 for-in문 처리를 종료합니다.

4.구한 값을 오브젝트로 변환합니다.
{설명} 
var sports = 12와 같이 오브젝트가 아닌 숫자를 할당한 후 for(var pty in sports){}문을
수행하더라도 에러가 발생하지 않습니다. 왜냐하면 for-in 문을 반복하기 전에 sports 값인 12를
number 오브젝트로 변환하지 않는다면 12가 오브젝트가 아니므로 에러가 발생합니다.

5.변환한 오브젝트를 열거합니다.
{설명}처음 열거하면 "soccer:11"이 읽혀지고 두 번째로 "basketball:5"가 읽혀집니다.

6.프로퍼티 이름을 pty 변수에 설정합니다.
{설명} soccer , basketball이 pty 변수에 설정됩니다.
var sports = {}와 같이 빈 오브젝트를 할당하면 에러가 발생하지 않지만 , 오브젝트에
프로퍼티가 없으므로 실행하지 않습니다. sports 오브젝트의 프로퍼티가 열거 불가이면 
처리하지 않습니다.

7.블럭안에 문장을 수행합니다.

8.break 문이 있으면 for-in루프를 종료합니다.

9.contunue 문이 있으면 continue문 아래를 수행하지 않고 5번으로 이동하비낟.

10.5번부터 9번까지 반복하여 수행합니다.


-for-in 루프 고려 사항
오브젝트의 프로퍼티가 이름으로 분류(Sort)되어 열거되지 않습니다.
-오브젝트에 작성한 순서로 열거된다고 보장하지 않습니다. 다만 열거할 뿐입니다.
반드시 작성된 순서를 원한다면 순서를 가진 배열(Array)을 사용해야 합니다.


[switch]

switch문은 표현식을 평가한 값과 일치하는 case 문장을 수행합니다.
일치하는 case를 만나면 그 아래 있는 모든 문장을 수행

형태
switch(표현식){
case 표현식 : 문장 리스트옵션
default : 문장 리스트옵션
}

소스 텍스트에 작성한 순서로 switch 표현식을 평가한 값과 case 표현식을 평가한 값을
비교합니다. 일치하는 case가 있으면 case 문장을 수행하고 일치하는 case가 없으면
default를 수행합니다. case를 다수 작성할 수 있습니다. default는 하나만 작성할 수 있으며
필수가 아닌 옵션이므로 작성하지 않아도 됩니다.

var exp = 2 , result;
switch(exp){
 case 1 : 
      result = 'case1';

 case 2 : 
      result = 'case2';

};

alert(result);



-switch문 수행 과정

1.switch(표현식)에서 표현식을 평가하여 값을 구합니다.
{코드}switch(exp)
{설명}exp 변수에 2를 할당했으므로 값은 2가 됩니다.

2.소스 텍스트에 작성한 순서로 case를 전부 추출합니다.
{설명} exp 변수에 2를 할당했으므로 값은 2가 됩니다.

3.추출한 case를 읽습니다.
{설명}더 이상 읽을 case가 없으면 default를 찾습니다.
default가 있을 때만 default를 수행하므로 작성하지 않더라도 에러가 발생하지 않습니다.

4.switch 표현식을 평가한 값과 case 표현식을 평가한 값을 비교합니다.
{설명}데이터 타입을 포함한 일치 === 연산자로 비교합니다.exp 변수의 값이 숫자 2이고
case "2"와 같이 문자로 작성하면 값은 같지만, 데이터 타입이 다르므로 case 2 문장을 수행하지 않습니다.

5. 값이 같지 않으면 3번으로 분기하여 다음 case를 읽습니다.

6.case 문장을 수행합니다.

7.소스 텍스트 끝까지 실행합니다.
{설명}switch 표현식 값과 일치하는 case가 있으면 case 아래의 모든 문장을 실행합니다.
따라서 일치하는 case에서 더 이상 처리하지 않고 종료하려면 case에 break 문을 작성해야 합니다.


-break 문 작성

var exp =1 , result;
switch(exp){
case 1:
    result = 'case1';

case 2:
    result = 'case2';

case 3:
    break;
    result = 'case3';
}


alert(result);


결과 : case2

exp 변숫값이 1이므로 case 1: 문장을 수행하게 됩니다. 따서러 결과는 case 1이 출력되어야 하나
case2가 출력 되었습니다. switch문은 일치하는 case를 만나면 그 아래에 있는 모든 문장을 수행합니다.
단, break 문이 있으면 그 위치에서 switch 문을 종료합니다.
case 1: 문장에서 result에 case1을 할당하고 아래로 내려가 result에 case2를 할당하며 다시 아래로
내려가게 됩니다. case 3:문장에서 break 문을 만나 종료하게 되므로 case2가 출력됩니다.

-default에 breack문 누락

var exp = 7 , result;

switch(exp){
   case 1: 
	result = 'case1';
   default : 
	result = 'default';
   case 3: 
	result = 'case3';
}

alert(result);

결과 : case3

exp 변수에 7을 할당했으며 case 7이 존재하지 않으므로 default 문장을 수행하게 됩니다.
default가 출력되지 않고 case3이 출력된 것은 default 문장을 수행한 후 아래에 있는 
case3: 문장을 수행하기 때문입니다. 의도적인 처리가 아니라면 default 문장에
break;를 작성해야 case 3: 문장이 수행되지 않습니다.



-소스 텍스트 중간에 default 작성

var exp=3 , result;
switch(exp){
   case 1:
	result = 'case1';
   default : 
	result = 'default';
	break;
   case 3: 
	result = 'case3';
}

결과 : case3

자바스크립트는 switch 문에서 default를 작성한 형태와 작성하지 않은 형태를 나누어서 처리합니다.
default를 작성하면 우선 default 앞의 모든 case를 소스 텍스트에 작성한 순서로 리스트를 만들며
이어서 default 이후의 case 리스트를 만듭니다. default를 작성하지 않으면 전체가 case이므로
구분할 필요가 없습니다.

먼저 앞 기준 리스트에서 switch 표현식 값에 일치하는 case를 찾고 존재하지 않으면
이후 기준 리스트에서 찾습니다. 일치하는 case 문장을 수행한 후 아래에 default가 있으면 수행 합니다.
소스에는 default가 있지만 case 3: 위에 있어 default를 수행하지 않으므로 결과는 case3이 됩니다.




-OR(||) 형태의 case문

var exp = 2 , result
switch(exp){
   case 2 :
   case 3 : 
   result = 'case23';
}


결과 : case23



[with]

with문은 오브젝트를 사용하여 문장을 수행합니다.

형태 with(오브젝트){문장}

var sports = {player : '11명', time = '90분'};

for(var pty in sports){
alert(sports[pty]);
}

결과
1. 11명
2. 90분


var sports = {player : '11명', time : '90분'};

with(sports){
   alert(player);
   alert(time);
}

결과
1. 11명
2. 90분


with 문의 파라미터에 sports 오브젝트를 지정하면 {player : '11명', time : '90분'} 형태의
오브젝트가 설정됩니다. with 블록에 player , time과 같이 프로퍼티 이름만 작성했는데 값이
출력되었습니다. with 문의 파라미터에 지정한 오브젝트에서 프로퍼티 값을 구하려면
오브젝트를 작성하지 않고 프로퍼티 이름만 작성합니다.

for-in 문은 오브젝트의 프로퍼티를 하나씩 읽어가면서 반복하므로 블록 문장에서 프로퍼티 값을 
추려내는 처리를 프로퍼티 단위로 할 수 있습니다. with 문의 오브젝트 프로퍼티 전체를 
펄쳐 놓은 모습이므로 프로퍼티 값을 추려내려면 대상 프로퍼티 이름을 하나씩 작성해야합니다.

한편 프로퍼티 이름만으로 값을 구할 수 있도록 하기 위해서는 자바스크립트 내부에서 이에 맞도록
환경을 만들어야 합니다. 그런데 환경을 만드는 것이 자바스크립트 구조에 맞지 않습니다. 이에 대한
논리는 사전 설명이 필요하며 "24.8절 오브젝트 환경 레코드"에서 다루고 있습니다.

-strict 모드

strict 모드느 ES5에서 제시된 것으로 단어 의미 그대로 엄격하게 자바스크립트 문법을 적용합니다.
첫 번째 줄이 'use strict';형태로 작성합니다.

'use strict';

with({player : '11명', time : '90분'}){
   alert(player);
   alert(time);
}

위 코드를 실행하면 에러가 발생하여 값이 출력되지 않습니다. 브라우저의 개발자 도구 콘솔 창에
strict 모드에서 with문을 사용할 수 없다는 메시지가 표시됩니다.
이는 되도록 with문을 사용하지 말라는 권고입니다. 이에 대한 논리는 사전 설명이 필요하며
"23장 스코프"에서 다루고 있습니다.



[try-catch-finally]

try문은 예외 발생을 인식하고 대응합니다.

형태
try {} catch(식별자){}
try {} finally{}
try {} catch(식별자){} finally{}


프로그램 실행 중에 에러가 발생하면 프로그램이 중단되지만 try블럭에 작성한 코드에서
에러가 발생하면 프로그램이 중단되지 않습니다. 따라서 에러가 발생할 가능성이 있는 
코드는 try 블록에 작성해야 합니다.

catch 블록에 발생한 예외를 받아 처리하는 코드를 작성합니다. try 블럭에서 예외가 발생하면 자동으로
catch 블럭이 실행되고 예외가 발생하지 않으면 실행되지 않습니다.
예외 발생 여부와 관계없이 finally 블록이 있으면 실행됩니다.


var sports;

try{
alert('try');
sports = swim;
}catch(e){
 alert('catch');
}finally{
 alert('finally');
}


1.try
2,catcg
3.finally

try블록에서 sports 변수에 swim 변숫값을 할당할 때 swim 변수가 존재하지 않으므로 에러가 발생합니다.
에러가 발생하면 catch 블록을 수행하므로 2번에 catch가 출력되었습니다. 3번이 출력된 것은 에러가 
발생하더라도 finally 블럭을 수행하기 때문입니다. try-catch-finally문은 아래와 같은 순서와
방법으로 예외를 처리합니다.

-try문
선언하지 않은 변수를 사용하면 에러가 발생하여 프로그램이 중단됩니다. 이때 try문을 사용하여 예외를
발생 시키면 프로그램이 중단되지 않습니다. try문은 블럭{}애 문장을 작성하며 블록을 생략할 수 없습니다.

코드는 try문을 설명하기 위해 작성한 것으로 좋은 코딩이 아닙니다. swim변수를 작성하지 않아 에러가
발생하게 된다는 것을 알 수 있을 때는 try문 앞에서 처리하는 것이 좋은 코딩입니다.


-catch(식별자) 블록

catch 블록은 try 블록에서 예외가 발생했을 때 자동으로 실행됩니다. catch(e) 파라미터에 e를
작성했으며 예외 오브젝트가 e에 설정됩니다. e는 식별자로 error과 같이 임의의 이름을
작성할 수 있습니다. 

e파라미터에 속성을 보면 message 프로퍼티가 있으며 예외가 발생한 이유가 텍스느로 작성되어 있습니다.
하지만 영문 텍스트이고 브라우저마다 메시지가 다르므로 한국에서 message를 그대로 사용하기에는 
어려움이 있습니다. 다음 절의 throw문을 사용하여 한글로 메시지를 표시할 수 있습니다.


-finally 블록

finally 블록은 예외 발생과 관계없이 작성되어 있으면 실행됩니다. catch 블록과 finally 블록 중에서
하나는 반드시 작성해야 하며 모두 작성할 수도 있습니다. 모두 작성했을 때 예외가 발생하면
catch블록을 수행한 후 finally 블록을 수행합니다. 예외가 발생했을 때 catch 블록을 작성하지 않고
finally 블록만 작성하면 finally 블록을 수행한 후 프로그램이 중단되므로 catch 블록을 작성해야 합니다.

[throw]

throw 문은 인위적으로 예외를 발생시킵니다.

형태 throw 표현식;

throw 문에서 값을 던지면 catch 블록이 받습니다. throw 문의 표현식을 평가한 값이
catch(e) 블록의 파라미터 e에 설정됩니다. 표현식에 문자열, 숫자 , 오브젝트와 같은 데이터
타입을 지정할 수 있으며 표현식을 평가한 값이 이와 같은 데이터 타입이어도 됩니다.
try문에 throw 문을 작성하지 않고 별도로 작성할 수도 있습니다. 이에 대해 하나씩 살펴보겠습니다.

-문자열 표현식

var sports;

try{
 if(!sports){
  throw 'sports에 값 없음';
 }
}catch(e){
alert(e);
}

결과 : 'sports에 값 없음'

sports 변수를 선언만 했으므로 throw 문을 수행하게 되며 결과 throw문에 작성한 문자열이
출력되었습니다. thow 문에서 표현식 평가 결과를 던지면 catch(e) 블록에서 받으며
평가한 값이 catch(e) 문의 e에 설정됩니다. try 블럭에서 throw 문을 사용하지 않았을 때
Error 오브젝트가 catch(e) 문의 e에 설정되는 것과는 차이가 있습니다.

줄을 불리하여 throw와 표현식을 작성하면 throw 끝에 자바스크립트가 세미콜론을 
자동삽입하므로 한줄에 작성해야 합니다.

-오브젝트 표현식

var sports;

try{
	if(!sports){
	throw {message:'에러', reason : '변수를 선언만 함'};
	}
}catch(e){
alert(e.message);
alert(e.reason);
}


결과
1.에러
2.변수를 선언만 함

throw 문의 표현식에 오브젝트를 작성할 수 있습니다. catch(e)의 e에 오브젝트가 설정되므로
e.message와 같이 프로퍼티 이름으로 값을 구할 수 있습니다. 오브젝트이므로
message , reason과 같이 다수의 프로퍼티를 작성할 수도 있습니다.


-Error 인스턴스 생성

var sports;

try{
	 if(!sports){
	throw new Error('Error 인스턴스');
	}

}catch(e){alert(e.message);}


결과 : Error 인스턴스

throw 문에서 new 연산자로 Error 인스턴스(Instance)를 생성하였으며, catch 블록에서
e.message로 인스턴스를 생성할 때 파라미터에 지정한 문자열 값을 출력하였습니다.


-별도 함수 사용

function showError(name){
	throw name + '를 선언하지 않았습니다.';
};

try{
 if(typeof sports == 'undefined'){showError('sports');}
}catch(e){
alert(e);
}

결과 : sports를 선언하지 않았습니다.

try블록에서 함수를 호출하고 호출된 함수에서 throw 문으로 표현식 평가 결과를 던지면
catch 블록이 받아 실행합니다. 이때 throw 문의 표현식 평가 결과가 catch 블록의 파라미터에 설정됩니다.


[debugger]
debugger가 작성된 위치에서 프로그램 실행이 멈춥니다. 개발자 도구에서 멈춘 시점의 실행
상태를 제공하므로 프로그램을 개발하거나 테스트할 때 유용합니다. 개발자 도구 창이 표시되어 있어야 실행이
멈춥니다. ES5 버전에서 제공합니다.

일반 사용자가 개발자 도구를 사용하지 않으므로 소스 코드에 debugger를 작성하더라도
프로그램이 멈추지 않지만 만약을 위해 배포판에는 작성하지 않습니다.

var sports = 123;
debugger;
alert(sports);

개발자 도구 창을 열고 실행을 시키면 debugger가 작성된 위치에 프로그램이 멈춥니다.
오른쪽 창에서 sports 변숫값을 비롯하여 실행 상태를 볼 수 있습니다.

[자바스크립트 기준과 범위]

자바스크립트는 객체 지향 프로그래밍(OOP : Object Oriented Programming) 언어입니다.
ES5 스펙에 ECMAScript is an object-oriented programming language 라고 기술 되어 있습니다.

자바스크립트는 스크립트 언어 입니다. 스크립트 언어 환경에서 객체 지향 프로그램을 구현하며,
객체 지향 환경에서 스크립트 언어로 프로그램을 구현 합니다. 이것이 자바스크립트의 기준 범위입니다.

객체 지향 프로그램을 구현하는 방법은 언어마다 차이가 있습니다. 사전 컴파일 언어와 
스크립트 언어는 환경이 다르므로 구현 방법이 다릅니다. OOP 일부 개념을 지원하지 않거나
채용할 필요가 없는 개념도 있습니다. 자바스크립트도 이와 같습니다.

ES5 스펙에 객체 지향 프로그래밍 개녕이 작성되어 있지않으며 자바스크립트로 구현하는
방법이 기술되어 있습니다. OOP 개념을 다루는 것은 이책의 범위가 아니며 구현 중심으로 다릅니다.
ES5 스펙에 기술된 객체 지향 용어가 기준입니다. 자바스크립트 중심이므로 다른 언어와 비교하는
것은 자바스크립트를 이해하는 데 그다지 도움이 되지 않습니다. 이는 필자의 경험입니다.

-객체
사람도 객체이고 자동차도 객체입니다. 객체는 이처럼 실체가 존재하며 자체가 행위(Behavior)와
속성(Attribute)을 갖고 있습니다. 먹는 것이 행위이고 밥이 속성입니다. 밥,빵,과일을 먹을 수 
있으므로 먹는 행위는 다수의 속성을 가질 수 있습니다. 이것이 객체의 구성 요소입니다.

객체를 자바스크립트로 표현하면 아래 형태가 됩니다.

사람 = {
 eat : function(과일){
    과일을 먹는다;
   }
 quantity : '과일 1개';

}


eat는 과일을 먹는 행위를 나타내는 이름이며 quanity는 과일 1개를 나타내는 이름입니다.
eat에 접근하면 먹는 행위를 실행할 수 있으며 quanity에 접근하면 과일 1개 값을 구할수 있습니다.

자바스크립트 구현 중심으로 보면 객체보다 오브젝트가 더 어울립니다. 사전적 의미로 객체가
오브젝트이므로 차이가 없지만, 자바스크립트 프로그램 구현에서 보면 뉘앙스가 다릅니다.


-프로퍼티

자바스크립트 문법으로 오브젝트를 표현하면 object = {name:value} 형태가 됩니다. 
name 와 value 를 프로퍼티(Propery)라고 하며 name을 프로퍼티 이름 , value를 프로퍼티 값이라고 합니다.
 오브젝트는 프로퍼티로 구성되며 콤마로 구분하여 다수의 프로퍼티를 작성할 수 있습니다.
따라서 오브젝트는 프로퍼티(이름과 값)의 집합니다. 객체는 행위와 속성의 집합니다.


-오브젝트와 인스턴스

오브젝트를 사용하여 오브젝트를 생성하면 오브젝트가 반환됩니다. 이떄 반환된 오브젝트를
인스턴스(Instance)라고 하며 ES5 스펙에서도 안스턴스로 표기하고 있습니다.
new 연산자로 오브젝트를 생성하여 변수에 할당할 수 있으며 변수에 할당된 오브젝트가 인스턴스입니다.

인스턴스를 생성하는 목적은 무엇일까요?

오브젝트에 book 프로퍼티가 있다고 할 때, book 프로퍼티에 값을 설정하면 생성하는 모든 
인스턴스가 같은 값을 갖게 됩니다. 반면 생성한 인스턴스의 book 프로퍼티에 값을 설정하면 
오브젝트의 book 프로퍼티 값이 변경되지 않습니다. 따라서 인스턴스 마다 다른 값을 가질 수 있습니다.
이처럼 인스턴스마다 다른 값을 유지, 제어하기 위해 인스턴스를 생성합니다.

이는 보고서를 복사기로 복사한 것과 같습니다. 복사한 보고서에 메모를 하더라도 원본은 그대로 유지되므로
다시 복사했을 때 같은 내용이 복사됩니다.원본이 오브젝트이고 복사한 보고서가 인스턴스입니다.

-함수와 메소드

"과일을 먹다"를 자바스크립트 프로그램 구현 형태로 작성하면 아래 모습이 됩니다.

eat : function(과일){
   과일을 먹는다;
}

위에서 function(){...} 형태를 함수(function)라고 합니다. 함수는 오브젝트에 속해야 하며,
오브젝트에 함수를 다수 작성할 수 있으므로 이름을 가져야 합니다. 함수는 자바스크립트에서 
사용하는 용어로 객체 지향 프로그래밍의 일반적인 용어는 메소드(method)입니다.
함수와 메소드 모두 행위를 나타냅니다.

자바스크립트에서 함수와 메소드를 구분해야 하지만 사전 설명이 필요하므로 현 시점에서는
같게 보아도 됩니다. eat() 함수/메소드가 실행되면 "과일을 먹는다"와 같이 행동하게되며
이를 프로그램 구현 측면에서 보면 코드입니다. 함수는 오브젝트에 속해야 하고 이름을
가져야 하며 함수 안에 함수의 목적 달성을 위한 코드를 작성합니다.

[빌트인]

브라우저가 grml 파일의 처음부터 한 줄씩 해석하다가 <script src="경로.js"></script>를
만나면 자바스크립트 실행 환경을 만듭니다. 이를 랜더링(Rendering)이라고 합니다. 렌더링을 완료한 후
src 속성의 source.js 파일 안에 작성한 자바스크립트 코드를 컴파일하고 실행합니다.

렌더링 단계에서 자바스크립는 오브젝트를 생성하고 값을 초기화하며 연산자를 설정합니다.
렌더링 단계에서 만드는 것을 총칭하여 빌트인(built-in)이라고 하며 빌트인은 크게 연산자,
데이터 타입, 오브젝트로 나눕니다.

-빌트인 목적용도
빌트인은 개발자 프로그램이 실행되기 전에 생성되므로 프로그램에서 사용할 수 있습니다.
예를 들어 == 연산자가 만들어져 있지 않다면 먼저 == 연산자를 사용할 수 있는 환경을
만들어야 합니다. 하지만 이와 관련된 어떤 처리를 하지 않아도 (sports == 'swim')과 같이
==연산자를 사용할 수 있습니다. 이 개념이 빌트인입니다.

(sports === null)에서 null이 빌트인 데이터 타입입니다. 자바스크립트가 null을 사전에 만들지 않는다면
개발자 프로그램에서 만들어야 합니다. 빌트인은 자바스크립트가 생성하며 개발자 프로그램에서
사전 처리를 하지 않고 사용할 수 있습니다.

빌트인에서 자바스크립트 특징을 나타낸 것이 빌트인 오브젝트입니다. 언어에 따라 다르지만 , 
문자열을 처리하려면 먼저 문자열 오브젝트를 만들어야 하며 문자열을 처리할 때마다
오브젝트를 만드는 것은 번거롭습니다. 하지만 자바스크립트는 문자열 처리를 위한 String 오브젝트를
빌트인 오브젝트로 제공하므로 오브젝트를 만들지 않고 문자열을 처리 할 수 있습니다.

-빌트인 연산자
++,--,+,-,~,!,*,/,%,==,!=,===,!== , = ,*=,/= ,%= 등

-빌트인 데이터 타입
Undefined , Null , Boolean , Number , String

-빌트인 오브젝트
Global , Object , Function , Array , String , Boolean , Number
Math , Date , RegExp , JSON
Error 처리용 (Error , EvalError , RangeError , ReferenceError , SyntaxError , TypeError , URIError)


[빌트인 오브젝트]

각 빌트인 오브젝트 개요를 살펴봅니다. 다음 장부터 빌트인 오브젝트에서 제공하는 메소드와 프로퍼티를 다룹니다.

-Global 오브젝트

글로벌(Global) 오브젝트는 전체를 통해서 하나만 존재하며 모든 프로그램에서 접근할 수 있습니다.
html 파일에 <script scr="경로1.js">와 <script scr="경로2.js">를 작성했을때 경로1.js 와 경로2.js의
코드에서 blobal 오브젝트의 프로퍼티를 공유합니다. 공유에 따른 장점도 있지만, 단점도
있습니다. 전역 객체라고도 하며 뉘앙스 차이가 있어 이 책에서는 글로벌 오브젝트로 표기합니다.

-Object 오브젝트

Object 오브젝트는 오브젝트를 생성 ,제어하며 대부분의 빌트인 오브젝트에 상속됩니다.
소스 텍스트에 var sports = {}; 와 같이 중괄호 {}를 작성하면 새로운 Obejct 오브젝트를 생성하여 반환합니다.
ES5 스펙에 기능이 추가되었습니다.

-Function 오브젝트

Function 오브젝트는 함수 오브젝트를 생성 , 제어합니다. 소스 텍스트에 function music(){}를 작성하면
새로운 Function 오브젝트를 생성하여 반환합니다. 자바스크립트는 Function 오브젝트로 시작해서 
Function 오브젝트로  끝난다고 해도 지나치지 않습니다.

-Array 오브젝트

Array 오브젝트는 배열을 생성, 제어합니다. 소스 텍스트에 var sports = [];와 같이 대괄호[]를
작성하면 새로운 Array 오브젝트를 생성하여 반환합니다. 배열을 정의하거나 분리 , 연결 , 추가 
,삭제 할 수 있는 메소드가 포함되어 있습니다. ES5스펙에 기능이 추가되었습니다.

-String 오브젝트

String 오브젝트는 문자열을 제어합니다. 문자열을 분리하거나 연결할 수 있으며 지정한 
위치의 문자열을 구할 수 있는 메소드가 포함되어 있습니다.

-Boolean 오브젝트

Boolean 오브젝트는 true와 false 값을 제공합니다.

-Number 오브젝트

Number 오브젝트는 숫자를 제어합니다.

-Math 오브젝트

Math 오브젝트 수학 계산을 위한 상수와 함수를 제공합니다.

-Date 오브젝트

Date 오브젝트는 날짜와 시간을 제공합니다. 년(Year), 월(Month) , 일(Day) , 시(Hour)
분(Minute) , 초(Second), 밀리초(milliseconds) 값을 구할 수 있습니다.

-RegExp 오브젝트 
RegExp 오브젝트는 정규 표현식을 위한 오브젝트로 문자열을 검색, 치환할 수 있습니다.
ECMA-262 스펙은 크게 자바스크립트 부분과 정규 표현식 부분으로 누눌 수 있습니다.
String 오브젝트에 정규 표현식을 사용할 수 있는 메소드가 4개 있으며 정규 표현식 오브젝트에
2개의 메소드(exec,test)가 있습니다. 이 책은 정규 표현식을 다루지 않습니다.

-JSON 오브젝트

JSON 오브젝트는 자바스크립트 형태의 값을 JSON 형태의 문자열로 변환하거나, 반대로 JSON
형태의 문자열을 자바스크립트 형태의 값으로 변환합니다. JSON 오브젝트는 ES5에서 제공합니다.


143페이지

obj.conact













































