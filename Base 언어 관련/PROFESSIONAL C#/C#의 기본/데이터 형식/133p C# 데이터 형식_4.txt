[박싱(Boxing)과 언박싱(UnBoxing)]

우리는 지금까지 int나 char와 같이 단순히 미리 정의된 데이터 형식을 비롯하여 클래스나
구조체와 같은 복잡한 데이터 형식들이 object 형식에서 파생된다는 것을 보았다. 이것은
리터럴 값까지도 객체처럼 다룰 수 있다는 것을 의미한다.

string s = 10.ToString();

C#의 데이터 형식은 값 형식과 참조 형식으로 나뉘는데 값 형식은 스택에 할당되어 데이터를
저장하고 있고 참조 형식은 미리 결정된 크기를 가지고 있는 것이 아니고 힙에 할당된다.
그렇다면 만약에 int가 스택에 저장된 단순한 4바이트의 값에 지나지 않는다면 우리는 어떻게
int의 메소드를 호출할 수 있을까?

이것은 박싱이라는 다소 마법 같은 것을 통하여 이루어진다. 박싱(boxing)을 통하여 값 형식을
참조 형식으로 변환하고 언박싱(unboxing)을 통하여 참조 형식을 값 형식으로 변환한다.
이것은 값 형식을 object 형식으로 캐스트하는 것과 같다. 박싱은 값 형식을 참조으로 변환하는
것을 표현하기 위한 용어이다. 기본적으로 런타임은 힙의 객체에 대해서 일시적인 참조
형식인 "박스(Box)"를 만든다.

이 변환은 앞의 코드에서처럼 암시적으로 이루어질 수 있으나 다음과 같이 수행될 수도 있다.

int i = 20;
object o = i;

언박싱(unboxing)은 반대로 참조 형식이 값 형식으로 변환되는 과정을 나타낸다. 이것은
명시적으로 행해져야 하기 때문에 캐스트라는 말을 사용한다.문법은 위에서 언급한 명시적인
형식 변환에 사용되는 것과 같다.


int i = 20;
object o = i; //int를 박싱한다.
int j = (int)o; //이것을 다시 int로 언박싱한다.


그리고 이전에 박싱된 변수만 언박싱시킬 수 있다.

한가지 유의할 점은 언박싱을 할 때 언박싱한 값이 대입될 데이터 형식이 언박싱할 데이터 형식의
원래의 바이트값을 모두 저장할 수 있어야 한다는 것이다. 예를 들면 C#의 int는 32비트의
길이를 가지고 있는데 64비트인 long 값을 언박싱해서 int로 대입하는 것은 오류를 일으키게 된다.
다음의 코드를 보자.


long a = 333333423; //a는 스택에 저장된 지역 long이다.
object b = (object) a;  //b는 a의 박스가 힙에 저장된 곳을 가리키는 참조 형식 변수이다.
int c = (int)b;  // 오류 : long 변소는 int로 언박싱된다.

여기에서는 a가 가진 64비트 길이의 long 값이 힙에 박싱되고, 32비트 길이의 int 변수에
언박싱 된다. 힙의 어떤 값을  값 형식 변수로 언박싱하는 것은 실행 시에 오류를 발생시키게 된다.
실행 시에 어떤 데이터 형식의 변수를 다른 데이터 형식으로 언박싱하여 오류를 일으키지 않도록
하려면 값 형식 변수를 박싱할 때 변수의 원래 데이터 형식을 기억하고 있어야 한다.


[변수(Variable)]

앞에서 살펴봤듯이 C#에서 변수를 선언할 때는 다음의 문법을 사용한다.

[modifiers] datatype identifier;

예를 들면,

public int i; //클래스 필드, 지역변수들은 엑세스 한정자들을 가지지 못한다.

이 명령문은 어디에서도  엑세스 할 수 있는 public의 엑세스 권한을 가지고 i라는
이름을 가진 int 형식 변수를 선언한다.컴파일러는 우리가 이 변수를 어떤 특정한 값으로 초기화
하기 전에는 이 변수를 사용하도록 허락하지 않는다. 하지만 선언을 하게 되면 4바이트가
스택에 할당이 된다.

일단 선언이 되면 대입 연산자(=)를 이용하여 값을 변수에 할당해 줄 수 있다.

i = 10;

만약 VB6를 사용했다면 다음을 명심하자. C#이 객체와 간단한 데이터 형식을 구분하지 않기
때문에 어떤 변수가 객체를 가리키도록 지정하고 싶더라도 Set이라는 키워드를 사용할 필요가 없다.

만약 하나의 명령문 안에 여러 개의 변수를 선언하고 초기화하고 싶다면 모든 변수는 같은 데이터 형식을
가지고 같은 액세스 권한으로 선언된다.

public static int x = 10 , y= 20; //x와 y는 둘다 public static int이다.

여러 개의 변수를 선언하는 데 서로 다른 한정자와 데이터 형식을 대입할 수 없으므로 다음과
같이 할 수 없다.

public int x = 10, private byre y = 20; 컴파일 되지 않는다.

마지막으로 알아 둘 것은 같은 범위 안에서 같은 이름의 변수가 두 번 선언될 수 없다는 것이다.
그래서 다음과 같이 할 수 없다.

int x = 20;
//약간의 코드
int x = 30;

그렇다면 변수의 볌위에 대해서 대강 알아보자


[식별자(Identifier)]

식별자는 변수,클래스나 구조체와 같이 사용자가 정의한 데이터 형식 , 그리고 이러한 데이터
형식의 멤버에게 지워지는 이름이다. 식별자는 대소문자를 구분하므로 identifier와 Identifier는
서로 다른 변수이다. C#에서는 어떤 식별자를 사용할 수 있는지에 관한 몇 가지 법칙이 있다.

첫째로 첫번째 문자는 반드시 영문자와 밑줄이어야 하는 것이고 , 두번째 문자부터는 숫자가
올 수 있다는 것이다. 그리고 다음의 76개의 C# 키워드를 식별자로 사용할 수 없다.


--------------------------------------------------------------
abstract , do , implicit , params , switch ,
as , double , in  , private , this,
base  , else , int , protected , throw ,
bool , enum , interface ,  public , true ,
break , event , internal , readonly , try ,
byte , explicit , is , ref , typeof
case , extern , lock , return , uint , 
catch , false , long , sbyte , ulong ,
char , finaly , namespace , sealed , unchecked ,
checked , fixed , new , short , unsafe ,
class , float , null , sizeof , ushort ,
const , for , object ,stackaloc , using ,
continue , foreach , oprator ,  static , virtual
decimal , goto , out , string , void ,
default , if , override , struct , while,
delegate

--------------------------------------------------------------

만약 다른 언어로 작성된 클래스를 사용해아 하는 경우처럼 이 키워드를 식별자로 사용해야 한다면,
컴파일러에게 이 단어는 C# 키워드가 아니라 식별자로 사용하러는 것을 명시하기 위해서 @문자를
식별자 앞에 붙여야 한다. 즉 abstract가 아니라, @abstract는 식별자로 사용 가능하다.

마지막으로 식별자는 \uXXXX (XXXX는 유니코드 문자를 위한 4자리 16진수 이다)의 형태를
가진 유니코드 문자를 포함할 수 있다.



[변수 범위(Variable Scope)]

이미 같은 범위 안에서는 같은 이름을 가진 변수들이 선언될 수 없다는 것을 언급했다.
변수의 범위란 변수가 사용될 수 있는 코드의 영역을 이야기한다. 다음의 코드를 보자.


using System;

public class ScopeTest
{
   public statuc int Main()
   {
	for(int i =0; i < 10 ;i++)
	{
	Console,WriteLine(i);
	}//i의 범위는 여기서 끝난다.

	//변수 i를 다시 선언할 수 있다.
	//이유는 범위 내에 동일한 이름을 가진 다른 변수가 없기 때문이다.
	
	
	for(int i =9; i >= 0 ;i--)
	{
	Console,WriteLine(i);
	}//i의 범위는 여기서 끝난다.

	return 0;
   }
}


이 코드는 단순히 0에서 9까지의 숫자를 출력하고 거꾸로 9에서 0까지의 숫자를 출력한다.
for루프의 문법은 뒤에서 살펴볼 것이니 너무 어려워 말자. 여기에서 눈여겨 볼 것은 변수 i가
두번 선언 되었다는 것이다. 이렇게 할 수 있는 이유는 두 군데 모두 i가 로프 안에 선언되어서
루프 내의 지역 변수이기 떄문이다. 루프가 끝나자마자 변수는 범위에서 벗어나게 되고 
더 이상 엑세스 가능하지 않게 된다.

다른 예를 하나 더 보다




using System;

public class ScopeTest
{
   public statuc int Main()
   {
	int j = 20;
	for(int i = 0; i <10 ; i++)
	{
	ing j = 30; //이렇게 할 수 없다 - j는 여전히 범위 안에 있다.
	Console.WriteLine(j+i);
	}
	return 0;
   }
}


[필드(Field)와 지역 변수(Local Variable)]

어떤 경우에는 다른 범위 내에 있는 같은 이름을 가진 두 개의 식별자를 구별할 수 있어서
컴파일러가 두번째 변수의 선언을 허용할 수 있다. C#에서는 데이터 형식의 내부에 선언되는 
변수들을 필드(field)로 정의하고 , 메소드 내에 선언된 변수는 따로 
지역 변수(local variable)라고 구별하기 때문이다.

다음의 코드를 보자.

using System;

public class ScoprTest
{
	static int j = 20;

	public static int main()
	{
	ing j = 30;
	Console.WriteLine(j);
	return 0;
	}
}


이 코드에는 j라는 이름을 가진 변수가 두개 선언되어 있다 . 하나는 클래스 수준에서 정의되고 
클래스가 소멸되기 전까지 범위를 벗어나지 않는다. 그리고 j라는 이름을 가진 또 하나의 변수는
Main 메소드 안에 선언되어 같은 이름을 가진 클래스 수준의 변수와 충돌을 일으키지 않는다.
그래서 이 코드는 컴파일되고 , 결과로 30을 출력하게 된다.

하지만 우리가 클래스 수준의 변수를 참고 하고 싶을떄는 object.fielddname이라는 문법을 이용하여
클래스나 구조체의 필드를 객체 밖에서 참조할 수 있다. 예를 들어 하나의 필드를 가진 클래스를
다음과 같이 정의하면,

class SomeClass
{
	public int i = 20;
}

i 필드에 다음과 같이 엑세스할 있다.

SomeClass obj = new SomeClass();
int x = obj.i;


일반적으로 필드는 현재 범위 안에서 유효하기 때문에 클래스 내부에서는 필드를 이런 식으로
사용할 필요가 없다. 만약 현재의 범위 내에서 같은 이름을 가진 지역변수를 선언해서 필드를
숨겨버렸다면 위의 문법을 이용하여 그 필드를 사용할 수 있다. 위의 예에서 정적 메소드 내에서
정적 필드를 사용하고 있다. 그래서 클래스의 인스턴가 필요하지 않고 그냥 클래스 이름과 함께
사용할 수 있다.

Console.WriteLine(ScopeTest.j);

만약 인스턴스 필드(클래스의 특정 인스턴스에 속한 필드)에 엑세스하길 원한다면, this 키워드를
사용하면 된다. this 키워드는 현재 인스턴스의 참조를 획득하기 위해 클래스나
구조체 내부에서 사용된다. 


[변수 한정자(Variable Modifier)]

변수를 선언할 떄 변수가 가질 수 있는 다양한 특성을 함께 지정해 줄 수 있다.
예를 들어 그 변수가 현재의 클래스 외부 코드에서 엑세스 가능한 것인지, 아니면
변수의 값이 변경될 수 있는지 등의 특성을 지정해 줄 수 있는데 다음의 한정자를
이용해 구현할 수 있다.

-internal
-new
-private
-protected
-public
-readonly
-static

이 한정자들은 지역 변수가 아닌 필드에만 사용 가능하다.

new 한정자는 다른 클래스로부터 상속받은 클래스에서만 사용가능하고 , 클래스 내의 필드를
숨기는 역할을 한다.

[접근성 한정자(accessobillity modifier)]

internal, private , protected , public의 한정자들은 변수의 접근성의 정도를 설정해 주는데
쓰인다. 각 변수 당 하나의 한정자만 사용하게 되는데, protected와 internal은 예외적으로 함께
사용 할 수 있다. 다음 표는 다섯 가지로 나누어진 접근성의 정도를 설명하고 있다.



접근성	/	설명

public  / 변수가 속한 데이터 형식의 필드로서 어디에서든지 변수에 엑세스 가능하다.

internal / 현재 프로그램에서만 변수에 엑세스 가능하다.

protected / 이 변수가 속한 데이터 형식, 혹은 이 데이터 형식으로부터 파생된
	    데이터 형식에서만 변수에 엑세스 가능하다.

protected internal / 현재 프로그램이나 현재 데이터 형식에서 파생된 데이터 형식으로부터
		     변수에 엑세스 가능하다.(즉 2가지의 접근성을 동시에 가지고 있다.)

private / 자신이 속한 데이터 형식에서만 변수에 엑세스 가능하다.



이 접근성의 의미가 무엇인지 알아보자. 두 개의 클래스를 갖는 프로그램을 작성하자.
첫번째 클래스의 이름은 AccessTest이고 , x라는 이름의 int 형식 변수를 하나 가지고 있다.
다른 클래스는 AccessTest클래스를 인스턴스화 하고 , 그 인스턴스의 x 변수를 제어할 것이다.


using System;

public class AccessTest
{
	public int x =12;
}

public class AccessClient
{
	public static int Main()
	{
	AccessTest Test = nwe AccessTest();
	int x = Test.x;
	Console.writeLine(x);
	return 0;
	}
}

이 파일을 AccessTest.cs로 저장한 후 csc AccessTest.cs 명령으로 컴파일하자. 이 경우에 x를
public으로 선언하였기 때문에 어디에서든지 엑세스 가능하므로 프로그램은 잘 동작할 것이다.
비슷하게 한정자를 internal이나 protected internal로 바꾼다고 하더라도 아무런 문제는 없다.
두개의 클래스는 같은 프로그램의 일부이고 함께 컴파일되기 때문이다.

protected internal int x = 12;

하지만 만약 한정자를 private나 protected로 바꾸면, 그 변수는 AccessClient에서 
보여질 수 없기 때문에 컴파일 시 다름과 같은 오류가 발생한다.

(보호 수준 때문에 "AccessTest.x"에 엑세스할 수 없습니다.)


이제는 두 개의 클래스를 따로 컴파일해보자. 첫번째로 AccessTest 클래스를 AccessTest.cs
 파일에 저장하자.


//AccessTest.cs
public class AccessTest
{
public int x =12;
}

이것을 다음 명령어를 사용하여 클래스 라이브러리로 컴파일하자.

csc /t:library AccessTest.cs

다음의 AccessClient 클래스를 AccessClient.cs 파일에 저장하자. using System을 이 파일의
첫번째 줄에 추가해야한다.

//AccessClient.cs

using System;

public class AccessClient
{
	public static int Main()
	{
	AccessTest objTest = new AcccessTest();
	int x = objTest.x;
	console.WriteLine(x);
	return 0;
	}
}


위에서 새롭게 컴파일한 AccessTest.dll을 참조하도록 하여 이 파일을 콘솔 응용프로그램으로
컴파일하도록 하자.


csc /r:AccessTest.dll AccessClient.cs


변수 x의 접근성이 public으로 되어 있으면 특별한 문제없이 컴파일되어 실행된다. 만약 
이 변수의 접근성을 protected나 protected intenal로 바꾸고 다시 두개의 파일을 컴파일 하면
AccessClient.cs 파일을 컴파일할 때 오류가 발생한다. 두 개의 파일은 독립적으로 컴파일되었기
때문에 C# 컴파일러가 봤을 때 같은 프로그램의 일부분이 아니기 떄문이다.


[정적 변수(static variable)와 인스턴스 변수(instance variable)]

이번 장을 시작할 때 보았던 "C# isn't Java" 예제에서 메소드를 static으로 선언하여 
그 메소드가 속한 클래스를 인스턴스화하지 않고 메소드를 호출할 수 있다는 것을 보았다.
마찬가지로 static 한정자를 이용하여 필드에 대해서도 같은 일을 할 수 있다. 기본적으로
필드는 인스턴스 필드(instance field)라고 하여 필드가 속한 클래스의 각 인스턴스마다
변수의 독립적인 복사본이 생성된다. 만약 변수 선언에 static 키워드를 추가하면 그 필드는
정적 필드(static field)가 된다. 이말은 클래스의 인스턴스가 몇 개 생기는가와 상관없이
필드에 대한 하나의 복사복만 생긴다는 것을 의미한다.

위 예에서는 변수 x를 선언하기 전에 AccessTest 클래스의 인스턴스를 먼저 만들어야 했다.
만약 변수 선언에 static 한정자를 추가하면 클래스의 인스턴스를 통하지 않고 클래스를
통하여 바로 그 변수에 엑세스할 수 있다.

using System;

public class AccessTest
{
	public static int x = 12;
}

public class AccessClient
{
	public static int Main()
	{
	int x = AccessTest.x;
	Console.WriteLine(x);
	return 0;
	}
}


[읽기전용(readonly) 변수]

우리가 살펴볼 마지막 한정자는 readonly이다. 말 그대로 이 한정자는 변수를 일단 한번 초기화하면
값을 수정할 수 없도록 읽기전용으로 만든다. 읽기전용 필드의 값은 오직 그 변수가 선언될 때나
그 변수가 속한 데이터 형식의 생성자에서만 초기화 될 수 있다. 만약 그 시점에서 초기화되지 않으면 
그 필드는 항상 기본값(숫자 데이터 형식에 대해서는 0 , 참조 형식에 대해서는 null)을 가지게 된다.
정적 읽기전용 필드는 인스턴스의 생성자에서 초기화될 수 없고, 인스턴스의 읽기전용 필드는
정적 생성자 내에서 초기화 될 수 없다는 사실을 알아두자.

읽기전용 변수는 메소드의 참조 인수나 출력 인수로 전달될 수 없다. 하지만 생성자에서는 예외이다.
출력 인수와 참조 인수에 대해서는 뒤에서 알아보기로 하자.


[상수(Constant)]

상수는 정적 읽기전용 필드와 매우 비슷하다. 어떤 변수를 선언하여 상수로 쓰려면 값을 초기화할
때 변수 앞에 constant 키워드를 붙이면 된다. 이름이 의미하는 것처럼 상수는 값이 바뀔수 없는 변수이다.

const int a = 100; //이 값은 변할 수 없다.

상수는 다음 네 측면에서 읽기 전용 필드와 다르다고 볼 수 있다.

-필드뿐만 아니라 지역 변수도 상수로 선언하 수 있다.

-상수는 반드시 선언될 때 초기화되어야 한다. 데이터 형식 수준에서 선언되며 생성자 내에서
 초기화될 수 없다. 한 번 값이 선언되면 변경될 수 없다.

-상수의 값은 컴파일 시에 계산 가능해야 한다. 고로 상수를 어떤 변수가 가지고 있는 값으로
 초기화할 수 없다. 만약 그렇게 하고 싶다면 읽기전용 필드를 사용해야 한다.

-상수는 항상 정적이다. 하지만 상수를 선언할 때 static 한정자를 상수 선언에 추가해줄 필요는 없다
 (실제로 컴파일러가 허용하지도 않는다.)

프로그램상에 상수나 읽기전용 변수를 사용하면 적어도 다음의 세 가지 이점은 있다.

-상수는 프로그램의 코드에서 판독 불가능한 숫자나 문자열을 대신해여 값의 의미를 이해하기 쉬운
이름이기 때문에 코드의 판독성을 높여준다.

-상수를 사용하면 프로그램을 수정하기가 쉬워진다. 예를 들어 세금계산 프로그램에서 SalesTax라는
상수를 선언하여 6%의 값을 할당했다고 가정하자. 만약 매출율이 이후에 바뀌어서 이 세금 계산
프로그램을 바꿔야 한다면 간단하게 SalesTax라는 상수의 값을 바꾸기만 하면 된다. 즉 기존 매출
세율의 의미를 가지고 있는 0.06이라는 숫자를 코드에서 일일이 다 찾아서 바꿔주는 작업을 하지
않아도 된다.

-상수는 프로그래밍 상의 실수를 방지해준다. 만약 이미 초기화한 상수에 다른 변수의 값을 할당하려고
시도하면 컴파일러는 이것이 오류라는 것을 알려준다.

열거형과 동일하게 상수는 전문가들이 사용하는 코딩의 정확도를 높이기 위한 일종의 규약이라고
말할 수 있다.




























































