[C# 데이터 형식]
자주 사용되는 데이터 형식을 수월하게 다룰 수 있도록 하기 위해서 , C# 컴파일러는 여러 개의
미리 정의된 형식을 CTS 안에 정의된 형식과 짝지어 인식한다. 예를 들어 CTS 형식을 이용하여 
다음과 같이 정수 변수를 선언할 수 있다.

------------------------------------------------------------------------------------------------

System.Int32 x;

------------------------------------------------------------------------------------------------

이것은 단순히 int, floaat 등의 형식을 사용하여 변수를 선언했던 개발자들에게는 다소 생소한
코드일지도 모르겠다. 정수 형식의 변수를 선언할 때마다 CTS의 System.Int32 형식을 매번
사용할 필요 없지 C#내에 정의된 대체 키워드인 int를 사용할 수 있다. 즉 아래와 같이
간단하지만 직관적인 방법을 사용할 수 있다.

------------------------------------------------------------------------------------------------

int x;

------------------------------------------------------------------------------------------------

이 두 가지 구문이 가지는 의미는 완전히 동일하다.

C#은 15가지의 미리 정의된 형식을 가지고 있는데 이 중 13개는 값 형식이고,
나머지 두 개(string 과 object)는 참조 형식이다.

[값 형식]
정수 형식 , 실수 형식 , 문자 형식 , 부울 형식 , 등과 같은 원시 데이터 형식은 값 형식이다.
C#와 C와 C++에서처럼 변수를 선언하는 데 있어서 편리한 문법을 제공한다. 
값 형식을 선언하기 위해서는 객체의 형식 이름을 적은 뒤에 객체의 이름을 쓰면 된다.
VB에서 사용했던 Dim이나 As 같은 키워드는 더 이상 필요 없다.

------------------------------------------------------------------------------------------------

int a; //이것은 정수 형식 변수 a를 스택에 선언한다.
 a = 100; //이것은 값 100을 a에 대입한다.

------------------------------------------------------------------------------------------------

혹은 좀더 편리하게 선언과 초기화를 함께 할 수 있다.

------------------------------------------------------------------------------------------------

int a = 100;

------------------------------------------------------------------------------------------------

C#에서는 한 줄에 여러 개의 변수를 동시에 선언하고 초기화 할 수 있다. 하지만
이러한 코드는 유지보수에 별로 도움이 되지 못하므로 되도록이면 피하도록 하자.

------------------------------------------------------------------------------------------------

int a = 100 , b, c=200, d;

------------------------------------------------------------------------------------------------

VB6 프로그래머는 특히 위의 문법에 주의해야 한다. VB6의 문법에 따르면 첫번째 변수는
정수 형식으로 정의되지만, 그 뒤에 변수들은 Variant 형식으로 정의된다.
C,C++,자바,C#에서는 다중으로 변수들을 선언할 수 있는데, 뒤에 오는 모든 변수들은 
첫번째 변수와 같은 데이터 형식으로 선언된다. 즉 a,b,c,d 모두 정수 형식이다.

값 형식 선언은 안전성을 강조하고 있는 C#의 다른 예를 보여준다. C# 컴파일러는 모든 값 형식의
변수를 사용하기 전에 명시적으로 초기화해 줄 것을 요구하고 있다. C++ 컴파일러는 이렇게
해주지 않으면 단순히 경고 메시지만을 보여주고 말지만 , C# 컴파일러는 이렇게 해주지 않으면
오류로 간주해 컴파일도 하지 않는다. 이것은 다른 프로그램이 사용하다 남긴 메모리의 쓰레기 값으로
변수가 초기화 되어 예기치 않은 오작동을 일으키지 않도록 사전에 방지해준다.

------------------------------------------------------------------------------------------------

public static int Main(){

ind d; 
Console.WriteLine(d); // 이렇게 할 수 없다. d를 사용하기전에 초기화 해주어야 한다.

}

------------------------------------------------------------------------------------------------

변수 d를 초기화 하지 않고 사용하는 코드를 컴파일하려고 하면 컴파일러는 
다음의 오류 메시지를 출력한다.

------------------------------------------------------------------------------------------------
파일경로 : Use of unassigned local variable 'd' (할당되지 않은 'd' 지역변수를 사용했습니다.)
------------------------------------------------------------------------------------------------

[정수 형식]

C#은 다음 8개의 미리 정의된 정수 형식을 지원한다.

이름 / 	 CTS 형식  / 	설명	  	/	 범위
sbyte / System.Sbtye / 8비트 부호가 있는 정수 / -128 ~ 127

short / System.Int16 / 16비트 부호가 있는 정수 / -32768 ~ 32767

int /  System.Int32 / 32비트 부호가 있는 정수 / -2147483648 ~ 214748347

long / System.Int64 / 64비트 부호가 있는 정수 / -9223372036854775808 ~ 9223372036854775807

byte / System.Byte / 8비트 부호가 없는 정수 / 0 ~ 255

ushort / System.UInt16 / 16비트 부호가 없는 정수 / 0 ~ 5535

uint / System.Uint32 / 32비트 부호가 없는 정수 / 0 ~ 4294967295

ulong / System.UInt64 / 64비트 부호가 없는 정수 / 0 ~ 1844744073709551615

-부호가 없는 정수에 -값을 넣으면 에러가 납니다.


------------------------------------------------------------------------------------------------

Windows의 다음 버전은 64비트 프로세서에 맞게 제작될 것이다. 이러한 발전에 쉽게 호환될수 있도록,
C#은 8비트에서 64비트의 크기를 갖는 부호가 있거나 부호가 없는 정수 형식을 지원한다.

byte는 0에서 255까지의 값을 갖는 8비트 단위이다. 형식 안전성을 위하여 C#은 byte 형식과
char 형식을 염격히 구분하기 때문에, 코드에서 이 두 가지 데이터 형식이 서로 변환되어야 할
상황에서는 명시적으로 표기되어야 한다. 정수 형식에 해당하는 여러 형식과는 달리 byte 형식은
원래 부호가 없다. 그것의 부호를 가지는 버전은 sbyte라는 특별한 이름을 가지고 있고 , 
-128 ~ 127까지의 정수를 나타낼 수 있다.

.NET에서는 short 형식의 길이가 별로 짧지 않다. short는 16비트이고 -32768 에서 32767까지의
수를 표시한다. 부호가 없는 버전은 ushort이라고 하며 0에서 65535까지의 수를 나타낼 수 있다.

int 형식은 32비트이고 -2,147,483,648에서 2,147,483,647까지의 수를 나태낼수 있다. 위와 마찬가지로
부가어 없는 버전은 uint라 하며 0에서 4,294,967,295까지의 수를 나타낼 수 있다.

long 형식은 64비트로서 -9,223,372,036,854,775,808 에서 9,223,372,036,854,775,807 까지의 수를 
표시하며, 부호가 없는 버전은 ulong으로 0에서 18,446,744,076,709,551,615까지의 수를 표현할 수 있다.

모든 정수 형식의 변수는 10진수 혹은 16진수의 표기법으로 쓰일 수 있는데, 16진수는 항상 앞에
0x를 붙여야 한다.

long x = 0x12ab;

만일 숫자가 int인지 uint인지, long인지, ulong인지 구분하기가 어렵다면 보통은 int라고 생각하면
된다. 특별한 정수 형식을 지정해 주려면 다음과 같이 수 뒤에 몇 개의 문자를 써주면 된다.

uint ui = 1234U;
long l = 1234L;
ulong ul = 1234UL;

소문자 u,l을 사용해도 되는데 소문자 l과 1을 혼동하지 않도록 주의한다.


------------------------------------------------------------------------------------------------

[부동 소수점 숫자(Floating Point Number)형식]

C#은 정수뿐만 아니라 부동 소수점 숫자에 대해서도 데이터 형식을 제공한다. 이것들은 기존의
C와 C++에서 쓰이던 것들과 비슷하다.

이름  /  CTS 형식  /       설명        / 소수점 아랫자리 

float / System.Single / 32비트 단일 정밀도 실수 / 7 

double / System.Double / 64비트 이중 정밀도 실수 / 15/16


float 형식은 소수점 이하의 숫자가 그다지 정밀할 필요가 없는 실수 형식의 값을 표현하는데 쓰인다.
각 float 변수는 소수점 이하 최대 7자리까지 표현할 수 있다. 

double 형식은 float 형식보다 휠씬 더 크고 소수점 이하로 15자리 까지 표현할 수 있다 . 

어떤 실수가 float 형식인지 double 형식인지 판단하기 힘든 경우에는 보통 double인 경우가 많다.
어떤 변수가 float 형식임을 명시하고자 한다면 F혹은 f를 뒤에 붙여 주면 된다.

float f = 12.3F


------------------------------------------------------------------------------------------------

[Decimal 형식]

부동 소수점 숫자보다 더 정교한 수를 나타낼 수 있는 decimal이라는 형식이 있다.


이름  /  CTS 형식  /       설명        / 소수점 아랫자리 

decimal / System.Decimal / 128비트 고정밀도 표기 / 28


CTS와 C#의 훌륭한 기능 중의 하나는 금융계산을 위한 데이터 형식이 제공된다는 것이다. 
이것이 decimal 형식이다. 소수점 아래로 28자리나 표현할 수 있는 기능을 이용하여 매우 큰 달러나
파운드의 돈을 센트 단위로까지 표현할 수 있고, 분수 형태로 표시된 큰 달러나 파운드의 돈을
더 정교하게 표현할 수 있다.

어떤 수가 double이나 float, 정수 형식 아니라 decimal 형식이라는 것을 명시하기 위해서는
M (혹은 m )을 다움과 같은 형태로 값 앞에 붙여준다.

decimal d = 12.30M;


------------------------------------------------------------------------------------------------

[부을(Bool) 형식]

C#의 bool 형식은 ture 혹은 false를 가지는  부울값을 표현하기 위해 쓰인다.

설명      /    CTS 형식      /   값

bool     /  System.Boolean   / true와 false




------------------------------------------------------------------------------------------------

[문자(character) 형식]

단일 문자를 저장하기 위해 쓰인다. C# char 데이터 형식을 지원한다.

이름   /  CTS 형식    /  값

char   /  System.char / 단일 16비트 (유니코드) 문자를 나타낸다.

이 데이터 형식은 C와 C++의 char 형식과 매우 비슷하지만 중요한 차이점을 가진다.

형식 안전성을 설명할 때 , char 형식과 8비트 byte 형식의 상호 변환은 불가능하다고
언급하였는데 두 데이터 형식의 크기가 서로 다르기 때문이다. 즉 char 형식은 8비트가 아닌
16비트로 이루어져 있다.

8비트를 사용하여 모든 영문자와 0에서 9까지의 숫자를 충분히 표기할 수 있지만,
한글같이 좀 더 확장된 문자 체계내의 모든 문자를 표현하는 데는 턱없이 부족하다.
세계화에 맞는 프로그램을 작성하기 위해서 소프트웨어 업체는 소프트웨어를 작성할 때 8비트 문자
집합 기반에서 프로그래밍을 할 것이 아니라, 아스키코드를 부분 집합으로 갖는 유니코드 체계를
기반으로 프로그래밍을 해야 할 것이다.

특히 안전하지 않은 코드(unsafe code) 내에서 포인터를 이용하여 char 변수들을 제어할 때는
char 값이 16비트 유니코드 값이라는 것을 명심하자.

문자는 'A'처럼 단일따옴표로 문자를 감싼 형태로 표현될 수 있다. 만약 문자를 겹따옴표로
감싼다면 컴파일러는 이것을 문자열로 인식하여 오류를 발생시킨다.

char를 단일따옴표 안의 문자로 표현할 수도 있고, 예를 들면 u0041와 같이 4자리 16진수
유니코드 값으로 표현할 수도 있고(char) 65처럼 정수값을 캐스트하여 표현할 수도 있고,
x0041처럼 16진수 값으로 표현할 수도 있다. 그리고 다음의 이스케이프 
시퀀스(escape sequence)를 포함한다.


이스케이프 시퀸스  / 문자
\'  / 단일따옴표
\"  / 겹따옴표
\\  / 백스래시(backslash)
\0  / Null
\a  / Alert
\b  / 백스페이스(backspace)
\f  / 폼 피드(form feed)
\n  / 새 줄(newline)
\r  / 캐리지 리턴(carriage return)
\t  / 탭 문자(tab)
\v  / 수직 탭(vertical tab)


C#은 string(문자열) 형식을 기본 데이터 형식으로 정의하고 있기 때문에 독자는 C++처럼 문자열을
char의 배열로 생각할 필요가 없다.


[참조 형식]

C#은 매우 제한적인 포인터 사용만을 허용한다고 이야기했다. 그렇다면 C# 프로그래머는 어떻게
힙 안의 객체를 조작할 수 있을까? 우리가 Something이라는 클래스를 가지고 있다고 가정하고
다음의 코드를 살펴보자.

Something objSomething;

C++에서 위 코드는 Something 클래스의 인스턴스를 스택에 생성하고, objSomething으로
그것을 참조시킨다. C#에서 이 코드는 아직 초기화되지 않은 Something의 참조를 만든다.
초기화되지 않은 null 참조를 통하여 이 객체에 엑세스하려고 시도하면 오류가 발생한다.

C#의 참조 객체 인스턴스는 new 키워드를 사용하여 생성한다. C#에서는 참조를 하나 만든
다음 new 키워드에 의해 힙에 할당된 객체를 참조가 가리키게 지정한다.

Something objSomething;  // 이 참조는 어떤 것도 가리키고 있지 않다.
objSomething = new Something //이것은 Something을 힙에 초기화 한다.


C#은 다음 두가지의 미리 정의된 참조 형식을 지원한다


이름    /     CTS형식	/ 설명
object / System.Object / 값 형식을 포함한 CTS의 모든 데이터 형식이 파생되는 근본 형식
string / System.String / 유니코드 문자열


[Object 형식]

많은 프로그래밍 언어와 클래스 계층은 다른 모든 객체가 파생되는 근본 형식을 우선 정의하고 있다.
C#과 .NET도 예외가 아니다. C#에서는 object 형식이라는 것이 그러한 역할을 한다.

어떤 객체를 다른 특정한 서브 형식으로 바꿀 때 object 참조를 쓴다. 예를 들면 스택의 값 형식
객체를 힙으로 옮기려면 값 형식 객체를 박싱(boxsing, 여기서 박싱이라는 것은 값 형식을 
참조 형식으로 바꾸는 것을 의미한다)해야 하는데, 이를 위해 object 형식이 사용된다. 코드가 형식을
알 수 없는 객체를 조작해야 할 떄가 있는데 객체 참조는 리플렉션(reflection:반사)에 있어서도 
매우 유용하게 쓰인다.

그리고 object 형식은 Equal(), GetHashCode() , GetType() , ToString() 같이 기본적이고
일반적인 메소드를 구현하는 데 사용된다.사용자가 정의한 클래스가 다른 데이터 형식과
더불어 잘 동작하게 만들고 싶다면 오버라이딩(overriding)이라고 하는 객체 지향 프로그래밍의
기법을 사용하여 어떤 메소드를 별도로 구현해야 한다(4장에서 자세히 알아볼 것이다.)
예를 들어 ToString()을 오버라이드했다면 클래스는 자기 자신을 문자열로 표현할 수 있는
메소드를 가지게 된다. 만약 클래스 내에 이러한 메소드를 개별적으로 정의해놓지 않는다면
컴파일러는 object 내의 메소드를 그대로 사용할 것이다.


[문자열(String) 형식]

C나 C++에서는 문자열이 단순히 문자의 배열에 지나지 않앗다. 그래서 클라이언트 프로그래머는
어떤 문자열을 다른 문자열로 복사하거나 두개의 문자열을 붙이기 위해 지저분한 코드를
작성해야 했다. 사실 C++에서 문자열의 다양한 작업을 수행하는 클래스를 작성하는 과정은
복잡한 메모리 연산과 API를 필요로 할 뿐만 아니라, 메모리 누수나 오버로드(overload)된
연산자의 많은 버그를 잡아야 하기 때문에 매우 짜증나는 작업이었다.

하지만 C#은 독자적인 문자열 형식을 제공한다. 두 개의 문자열을 붙이거나
문자열을 복사하는등의 작업은 매우 간단하다.

string str1 = "Hello";
string str2 = " World";
string str3 = str1 + str2;

이렇게 값 형식의 변수를 대입하는 것처럼 간단한 형태를 가지고 있음에도 불구하고
CTS의 System.String 형식은 참조 형식이다. 좀더 내부로 들어가 보면 문자열 
객체는 스택이 아니라 힙에 할당된다.그래서 우리가 어떤 문자열 변수를 다른 문자열 
변수로 할당하면 메모리상의 동일한 문자열을 가리키는 두 가지 참조가 생성된다. 
하지만 이 두개의 문자열 중에 하나를 변화시킨다면 다른 문자열은 변화시키지 않고 완전히
새로운 문자열 객체가 생성된다. 다음의 코드를 보자.

using System;

class StringExample{
	public static int Main(){

            string s1 = "A string";
            string s2 = s1;
            Console.WriteLine("s1 is " + s1);
            Console.WriteLine("s2 is " + s2);

            s1 = "Another string ";
            Console.WriteLine("s1 is " + s1);
            Console.WriteLine("s2 is " + s2);

	}
}


다른 말로 s1의 값을 바꾸는 것은 s2에 어떠한 영향도 끼치지 않는다. 그런데 이것은 우리가
지금까지 생각해왔던 참조 형식의 기능과는 모순이다. s1이 "A string"으로 초기화되면 새로운
객체가 힙에 할당된다. s2가 초기화되면 참조는 같은 객체를 가리키게 되고, s2는 "A string"이라는
값을 가지게 된다. 하지만 힙에 할당된 그 객체의 값을 변화시키는 것이라 , s1의 값만 변화시키면
새로운 값을 위하여 새로운 격체가 힙에 할당된다. 그래서 s2 변수는 여전히 최초의 객체를
가리키게 되고 값은 바뀌지 않는 것이다.

문자열은 겹따옴표로 시작하여 겹따옴표로 끝난다. 만약 문자열을 단일따옴표를 이용하여 표시
하면 컴파일러는 그것을 문자로 간주하여 오류를 발생시킬 것이다. C#의 문자열은 문자와 같은
유니코드와 16진수와 이스케이프 시퀸스를 가질 수 있다. 이스케이프 시퀸스는 백슬래시와 함께
사용되므로 우리는 백슬래시를 문자열 내에서 단독으로 사용할 수 없다. 대신 다음과 같이
백슬래시를 하나 덧붙여서 사용할 수 있다.

string filepath = "C:\\경로작렬";

이렇게 사용해야 한다는 것을 항상 기억하고 있다고 하더라도 백슬래시를 두 개 입력한다는 것은
꽤나 번거로운 일이다. 편리하게도 C#은 이렇게 작은 배려도 아끼지 않았다.
문자열 앞에 다음과 같이 @를 붙이면 문자열의 모든 문자는 이스케이프 문자로 인식되지 않고
그래도 인식된다.

string filepath = @"C:\경로작력"

그래서 문자열을 몇 줄로 나누어 쓸 수도 있다.

string Jabberwocky = @ " 'Twas brillig and the slithy 
toves Did gyre and gimble in the wabe."

그런데 위의 방법을 사용하면 문자열이 의도하지 않은 형태를 가지게 될 수도 있다. 아래처럼
문자열에 내용을 두 줄로 나누어 쓰면,

string Jabberwocky = @ " 'Twas brillig and the slithy 
		toves Did gyre and gimble in the wabe."

Jabberwocky의 값은 다음과 같이 된다. 즉 새 줄 문자 하나 이외에 20칸의 빈칸이 포함된다.

'Twas brillig and the slithy toves 				Did...'


[복잡한 데이터 형식]

앞에서 이야기한 미리 정의도니 형식뿐만 아니라 C#과 .NET 프레임 워크는 사용자 자신만의
복잡한 데이터 형식을 정의할 수 있는 기능을 제공한다. 대부분의 복잡한 데이터 형식은 뒷장에서
자세히 다르게 되겠지만 C#의 모든 복잡한 데이터 형식을 간단하게 살펴보도록 하자.
원시 데이터 형식과 같이 복잡한 데이터 형식도 값 형식과 참조 형식으로 나뉜다.


[값 형식]

우리 스스로 정의할 수 있는 값 형식에는 두 가지 종류가 있다. 우리는 이미 구조체(sturct)에
대해서 간단하게 알아보았다. 추가로 열거형(enumeration)이라고 하여 미리 정의된
특정한 값들을 표현하기 위한 데이터 형식도 정의할 수 있다.


[구조체(struct)]

이미 알고 있듯이 스택에 할당되는 형식은 힙에 할당되는 형식에 비해서 적어도 세 가지 이점을
가지고 있다. 첫번째로 스택이나 값 형식은 힙에 할당되는 형식에 비해서 더욱 빨리 할당된다.
두번째로 스택의 값 형식 변수는 범위에서 벗어나면 자동으로 메모리에서 해지된다.
세번쨰로 가장 중요한 것인데 값 형식 변수끼리는 복사하기가 쉽다. 그냥 =부호 하나만
사용하면 된다.

int a = 100;
int b;
b = a;

값 형식 변수에 비하여 힙의 객체를 복사하는 것은 어렵다. 대개 힙의 객체를 복사하기 위해서는
어떤 특별한 메소드를 구현해야 한다.

C#에서 구조체는 참조 형식이 아닌 값 형식으로써, 특별한 종류의 클래스라 생각할 수 있다.
구조체는 스택에 저장되기 때문에 클래스보다 간소하며 좀 더 효율적으로 만들어지고 복사될 수 있다.
Subscriber(구독자)를 나타내기 위한 다음의 구조체를 보자.

public struct Subscriber
{
	public long SubscriberID;
	public string FirstName;
	public string MiddleName;
	public string LastName;
	public decimal Balance;
}

만약 하나의 구조체를 다른 구조체로 복사하고자 한다면 사용할 수 있는 것은 = 부호뿐이다.
밑에서는 하나의 Subscriber 객체인 objSubscriber1을 만들고 그것의 값을 설정한다.
마지막 한 줄은 objSubscriber1에서 또 다른 subscruber 구조체의 인스턴스인 objSubscriber2로
모든 구조체의 필드값들을 복사하는 코드이다.

Subscriber Subscriber1;
Subscriber Subscriber2;


Subscriber1 = new Subscriber();
Subscriber1.FirstName = "John"'
Subscriber1.MiddleName = "Q";
Subscriber1.LastName = "Public";
Subscriber1.Balance = 100;

Subscriber2 = Subscriber1;

구조체가 값 형식임에도 불구하고 초기화되기 위해 new 연산자가 사용되었는 사실을 눈여겨 보자.
하지만 구조체는 new를 호출하기 전에도 실제로 사용 가능하고, 우리는 이것의 필드에 엑세스할 수 있다.
이 구조체는 선언되자마자 초기화될 수 있는데 이 모든 필드들은 기본값인 0으로 초기화된다.
하지만 컴파일런느 new 키워드를 이용하여 처음 초기화를 시켜주지 않거나 모든 필드의 값을
설정해주지 않으면, 구조체를 복사하거나 이것의 필드값을 읽을 수 없도록 막고 있다.

구조체를 복사하는 코드도 간단하지만 구조체의 함수를 호출하는 코드도 간단하다. 사실 프로그래머는
다른 함수의 매개변수로 전달해야 하는 값을 한데 묶기 위해 구조체를 사용하는 경우가 대부분이다.
함수에 여러 개의 매개변수를 별도로 전달하는 것보다는 하나로 묶어서 전달하는 것이 휠씬
더 간편하기 때문이다.


//구조체에 정보를 로드한다.
DataAccess.LoadSubscriber(out SubscriberID, subscruber);

//정보를 수정한다.
Subscriber.decBalance = Subscriber.decBalace -100;

//새로운 정보로 데이터베이스를 업데이트 한다.
DataAccess.UpdateSubscriber(SubscriberID, Scbscruber);


 C나 C++에서 사용하던 구조체와는 많이 달라졌다. C나 C++에서 클래스와 구조체의 단 한 가지
큰 차이점은 구조체에서 모든 멤버 데이터는 private가 아니라 기본적으로 public이라는 것이었다.
하지만 C#의 구조체는 기본적으로 private일 뿐만 아니라, 클래스와는 달리 구조체의 인스턴스는
메모리상에 별도의 장소에 할당한다.

C#에서 구조체는 구현 상속(implementation inheritance)을 지원하지 않음에도 불구하고 클래스가
할 수 있는 대부분의 일을 할 수 있다. 구조체의 인스턴스는 스택의 공간을 차지하고 있기 떄문에
상대적으로 작은 크기의 객체를 표현하는 데 적합하다. 이 이유 때문에 구조체가 .NET 프레임워크의
다른 모든 값 데이터 형식을 구현하는 데 사용된다.



[열거형(enumeration)]

열거형은 사용자가 정의한 정수 형식이다. 열거형을 선언핼 때 열거형의 인스턴스가 포함할 수 
있는 어떤 특정한 값들의 집합을 정의해야 한다. 그것뿐만 아니라 사용자에게 익숙한 이름으로
값을 대신할 수 있다. 만약 코드에서 열거형의 인스턴스가 받아들을 수 없는 값을 할당하려고 
시도하면 컴파일러는 오류를 발생시킨다.

프로그래밍을 하다보면 열거형이 매우 유용하게 쓰이는 상황이 가끔씩 있다. 예를 들면 클래스를
디자인할 때 클래스의 프로퍼티가 몇 개의 이미 결정된 값들 중의 하나로 결정될 수 있는 상황이 있다.
혹은 setWindowLong과 같이 입력 매개변수 중 하나의 특정한 값에 따라서 다르게 동작하는 함수를
만들 때가 있다.

평이한 정수 형식이 아닌 열거형을 사용하면 아래와 같은 장점을 얻게 된다.

-미리 이야기했듯이 열거형을 사용하면 변수가 적절한 값으로 할당되었는지 쉽게 확인할 수 있어
코드를 유지 보수하기가 쉬워진다.

-열거형은 어떤 의미를 가지고 있는지 판독하기 힘든 숫자와는 달리 서술적인 이름을 사용하므로써
코드를 좀 더 명확하게 만들어 준다.

-열거형을 사용하면 또한 코드를 입력하기 쉽다. 만약 어떤 값을 열거형의 인스턴스에
대입하려고 할 때 VS.NET 통합 개발 환경은 인텔리센스 기능을 통하여 열거형의 인스턴스가
받아들일 수 있는 값들을 리스트 박스로 표시하여 키보드를 치는 횟수를 줄여준다.

프로그래밍에서 열거형을 사용하는 것은 많은 시간과 수고를 덜어주는 작은 방법 중의 하나이다.
열거형을 적절히 사용하는 것은 전문적인 개발자임을 나타내는 지표로 받아들여지곤 한다.

열거형을 다음과 같이 정의할 수 있다.


public enum TimeOfDay{
 Morning = 0,
 Afternoon = 1,
 Evening = 2
}


이 경우 에서는 열거형 내에 하루의 각 주기를 표현하기 위한 정수값을 사용하였다. 이 각 값을
열거형의 멤버처럼 제어할 수 있다. 예를 들면 TimeOfDay.Morning은 0을 나타낸다. 전형적으로
열거형은 적절한 값을 메소드에 넘겨주기 위해서 사용되거나 switch문의 분기 조건에 사용된다.



