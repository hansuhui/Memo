[연산자]
대부분의 C#연산자는 기존의 C와 C++가 사용하는 연산자와 비슷하지만 C와 C++에 익숙하지 않은
개발자들을 위해서 중요한 기능을 살펴보기로 하자.

C#은 다음의 연산자들을 지원한다. 그러나 sizeof, * , -> , & 이 네 가지 연산자는 C#의 형식
안전성 검사를 거치지 않는 안전하지 않은 코드에서만 사용 가능하다. 

범주 / 연산자
산술 / +,-,*,/,%
논리 / & , | , ^ , ~, && , || , !
문자열 붙이기 / +
증가와 감소 / ++ ,--
비트 시프트 / << , >>
비교 / == , !=  , < , > , <= , >=
대입 / = , += , -=, *=, /= , %=, &=,|= , ^= , <<= , >>=
멥버 엑세스(객체들에 대한 연산자) / .
인덱싱(배열과 인덱서에 대한 연산자) / []
캐스트 / ()
조건부(삼항 연산자) / ?:
객체 생성 / new
형식 정보 / sizeof(안전하지 않은 코드에서만 사용 가능) is typeof
오버플로우 예외 제어 / checked , unchecked
간접 연산자 , 주소 연산자 / * - >& (안전하지 않은 코드에서만 사용가능) []


C#의 연산자를 사용할 때 가장 유의해야 할 것은 C언어처럼 대입(=)과  비교(==) 연산자를
혼동하지 말아야 한다.

x = 3; // 하나의 - 기호는 대입이다.

위 명령문은 x에 3을 대입하라는 의미이다. 어떤 값을 변수 x에 대입하려고 하기 떄문에 = 를
하나만 사용하였다. 만약 x를 다른 값과 비교하려면 두 개의 =를 사용해야한다.

if (x==3) // 두 개의 = 기호는 비교이다.

C#의 매우 엄격한 형식 안전성 법칙 덕분에 비교 연산자를 사용해야 하는 곳에 대입 연산자를
사용하여 일어나던 오류는 이제 사전에 방지된다. C나 C++에서 다음 명령문은 오류를 일으키지 않는다.

if (x=3)

즉 변수 x에는 3이라는 값이 대입되고 , 이 연산이 성공적으로 끝나면 x = 3 이라는 연산은
불울 true 값으로 바뀌게 된다. 그래서 x의 값이 무엇이든 간에 항상 true로만 계산되어 우리가
의도했던 바는 완전히 틀리게 된다. 다행히 C#은 어떤 데이터 형식을 부울 형식으로 암시적으로 
변환하는 것을 허락하고 있지 않으므로, 이 명령문은 오류를 일으키게 하고 컴파일되지 않는다.

VB에서는 두 개의 문자열을 붙이기 위해 & 연산자를 사용했지만 C#에서는 + 연산자가 사용된다.
C#에서 &는 두개의 다른 정수값을 비트 단위로 AND 시키는데 쓰이고, |는 비트 단위로 OR 시키는데
쓰인다. VB 프로그래머에게는 생소하겠지만 , %는 나누가한 다음 나머지 값을 얻는데 사용한다.

C#에서도 포인터를 사용하므로 간접 연산자인 ->을 사용한다. C#에서는 포인터를 안전하지 않은
코드 블록에서만 사용할 수 있기 때문에, 이 연산자를 안전하지 않은 코드 블록에서만 
사용 할 수 있다.

[연산자 줄여쓰기]

C의 장점 중의 하나는 문법이 간결하여 개발자가 복잡한 연산들을 간단히 표현할 수 있다는 것이다.
증가와 감소 연산자(++,--)는 그러한 간결성을 가장 잘 보여주는 예이다. 이 연산자를 변수에
적용시키면 간단하게 변수의 값을 증가 혹은 감소 시킬 수 있다.

이 연산자를 피연산자의 앞 혹은 뒤에 붙일 수 있다. x++이나 ++xsk ahem x=x+1의 의미를 가지고
있는데 다른 값을 반환하는 차이점을 가지고 있다. 증가 연산자와 감소 연산자는 독립적인 명령문이다.
다른 말로 x++이나 ++x는 스스로 한 줄의 명령문이 될 수 있고 , 그런 경우에는 X = X+1 과 
동일한 의미를 가진다.

그리고 다른 명령문 안에서 사용될 수도 있는데 이때 x++와 ++x는 다른 의미를 가지게 된다.
++x는 이것이 계산에 사용되기 전에 먼저 값을 증가시킨다. 즉 x를 먼저 증가시킨 후,
증가된 새로운 값을 연산에 사용한다. 반대로 x++는 x의 값을 사용한 다음 그 값을 증가시키는 것을
의미한다. 다음의 예제는 이러한 경우의 차이점을 설명해준다.


int x =5;
if(++x==6){
   Console.WriteLine("This will execite");
}


if(x++ = 7){
   Console.WriteLine("This won't");
}


첫번째 if 조건문에서는 x가 먼저 증가한 다음, 6과 비교되므로 ture로 인식한다. 두번째 조건문에서는
x를 먼저 비교한 다음 , 7과 비교하므로 false로 인식한다.

-x ,  x-와 같은 감소 연산자도 증가 연산자와 같은 방식으로 쓰여진다.

+=, -=와 같은 연산자 줄여쓰기는 두 개의 피연산자를 가지며 첫번째 피연산자의 값을 여러가지
연산을 통하여 변경시키는 데 쓰인다. 예를 들면,

x += 5; 

는 다음과 같다

x = x + 5;

다음 표에 C#에서 가능한 연산자 줄여쓰기의 모든 경우를 나열해 놓았다.

x++ , ++x : 첫번쨰는 식이 계산된 다음 변수의 값을 증가하고 , 두번째는 선증가
x-- , --x : 후빼기 , 선빼기
x += y : x에 y을 더한다
x -= y : x에 y을 뺀다
x *= y : 곱한다.
x /= y : 나눈다
x %= y : 나머지를 구한다.
x >>= y :
x &= y
x |= y 
x ^= y

[삼항 연산자]

삼항 연산자인 ?:는 if..else를 줄인 형태이다. 이것은 어떤 조건이 true인지 false인지를 
판단하여 각 경우마다 다른 값을 반환한다. 문법은 다음과 같다.

condition ? true_value : false_value

condition은 부울 형식의 식이며 , true_value는 condition이 true일 떄 반환해줘야 하는 값이고,
false_value는 codition이 false일 때 반환해줘야 하는 값이다. 이 연산자를 적절하게 사용하면
코드를 매우 간결하게 작성할 수 있다. 다음은 부울값을 true 혹은 false로 재빨리 
변환해주는 예제이다.

//x는 정수이다.
Console.WriteLine(x>=0 ? "Positive" : "Negative");


다음과 같이 복수형이나 단수형을 표시하는데도 아주 편리하게 쓰인다.
int x = 1;
string s = x.ToString() + " ";
s += (x==1 ? "man" :"men");
Console.WriteLine(s);

이코드는 만약 x가 1과 같으면 man을 출력하고 , 그외의 수에 대해서는 복수형(men)을 출력해준다.


[checked와 unchecked]

checked와 unchecked 연산자를 명시적으로 사용하여 CLR의 스택 오버플로우 처리 방식을 설정 할 수 있다.

byte b = 255;
b++;
Console.WriteLine(b.ToString());

byte 데이터 형식은 오직 0에서 255까지의 수를 포함할 수 있다. 그래서 b의 값을 증가시키는 것은
오버플로우를 일으킨다. CLR은 컴파일러 옵션을 비롯해서 많은 선택 사항을 보고 이것을 어떻게
처리하는가를 결정한다. 그래서 오버플로우의 가능성이 있는 코드를 수행한 후 , 우리가
원하는 결과를 얻은 것인지 항상 확인해볼 필요가 있다.

이런 목적 때문에 C#은 checked 와 unchecked 연산자를 제공한다. 만약 코드의 블록을 checked로 
표시하면 CLR은 강제로 오보플로우를 체크하고 , 오버플로우가 일어나면 예외를 발생시킨다.

checked 연산자를 이용하여 코드를 바꾸면 다음과 같다.

byte b = 255;
checked{
  b++;
}
Console.WriteLine(b.ToString());


이 코드를 실행 시키려고 하면 오류가 발생한다.


/checked 컴파일 옵션을 이용하면 프로그램의 표시되지 않은 모든 코드에 대해서 오버플로우 검사를
하도록 설정할 수 있다.


오버플로우 검사를 수행하지 않으려면 다음과 같이 코드를 unchekced 시키면 된다.



byte b = 255;
unchecked{
  b++;
}
Console.WriteLine(b.ToString());

이 경우에는 어떤 예외도 발생하지 않는다. 그래서 255를 초과하는 값을 포함할 수 없는 byte형식 변수인
b는 오버플로우에 의해서 0의 값을 가지게 된다.


[is]

is 연산자는 객체가 어떤 특정한 데이터 형식과 호환가능한지 검사해준다. 예를 들면 변수가 object 형식과
호환가능한지 검사하려면 이와 같이 작성한다.

int i = 10;
if(i is object){
 //모든 것은 C#의 객체이다.
  Console.WriteLine("i is an object");
}


C#의 모든 데이터 형식은 object로부터 상속되기 떄문에 , int 형식도 object와 호환 가능하다.
따라서 i is object의 계산 결과는 true가 된다.


[sizeof]

스택에 저장된 값 형식의 크기를 바이트 단위로 알아내기 위해서는 sizeof 연산자를 사용한다.

string s = "A string";
unsafe{
   Console.WriteLine(sizeof(int));
}


위의 코드는 int의 바이트 단위의 크기인 4를 출력할 것이다.

sizeof 연산자는 안전하지 않은 코드에서 사용 가능함을 알아두자. 기본적으로 C# 컴파일러는 안전하지 
않은 코드를 컴파일시키지 않기 때문에, 연산자를 사용하려면 명령문 컴파일러에 /unsafe 옵션을 붙여서 
컴파일하거나 Visual Studio.NET의 [ALLow unsafe code blocks] 옵션을 설정해줘야 한다. 이 옵션은 프로젝트
프로퍼티 페이지의 [Configuration Properties] | [Build] 아래 [Code Generation]에서 찾을 수 있다.


[typeof]

typeof 연산자는 특정한 데이터 형식을 나타내는 Type 객체를 반환한다. 예를 들어 typeof(string)하면
System.String 형식을 나타내는 Type 객체를 반환한다. 이 연산자는 객체의 정보를 동적으로 찾아내기 위해서
리플렉션을 사용하고자 할 때 유용하다.


[연산자 우선순위]

다음은 C# 연산자의 우선순위를 나타내는 표이다. 가장 위에 있는 연산자들의 우선순위가 가장 높다. 
우건순위가 높다는 말은 여러 개의 연산자를 가지는 식에서 가장 먼저 계산된다는 것을 의미한다.


그룹 / 연산자
     / (), ., [], x++, x-- ,new, typeof, sizeof, checked ,unchecked
단항 / + ,- ,! ,~ ,++x ,--x , 캐스트
곱셈,나눗셈 / * , /, %
덧셈,뺄셈 / +-
비트 시프트 연산자 / << , >>
관계 연산자 / < , > , <= , >= , is
비교 / == , !=
비교 AND / &
비교 XOR / |
비고 OR / ^
부울 AND / &&
부울 OR / ||
삼항 연산자 / ?:
대입 / = , += , -= , *= , /= , %= . etc









