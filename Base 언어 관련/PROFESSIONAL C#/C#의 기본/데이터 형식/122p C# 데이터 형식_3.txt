[참조 형식]

클래스뿐만 아니라 C#은 인터페이스(interface) , 델리게이트(delegate) , 배열(array) 등의 여러가지
복잡한 참조 형식을 가진다.


[클래스]
클래스는 C#과 .NET 프레임워크에서 사용자가 정의하는 가장 기본적인 데이터 형식이다.
C#으로 작성된 거의 대부분의 실행 파일은 적어도 하나의 클래스를 가지고 있는데
(이론적으론 대신 구조체를 사용할 수 있다), 이것은 프로그램의 진입점인 Main 메소드를 가지고 있다.

클래스는 데이터 멤버(필드, 상수 , 이벤트)과 함수(대부분 메소드와 프로퍼티이지만 연산자나
그 외의 것)로 이루어진 복합적인 데이터 형식이다. 다른 말로 클래스는 어떤 객체를 제어하고
그 객체상에서 작업을 하는데 필요한 모든 데이터와 기능성을 캡슐화시켜 놓은 것이다.


[인터페이스(interface)]
인터페이스는 클래스를 구현하는 기능성을 정의하는 데 사용된다. 인터페이스는 프로퍼티와 메소드,
이벤트 , 인덱스(indexer)를 포함할 수 있으나 인스턴스화 될 수 없고 이러한 함수들의 구현을 
정의하지 못한다. 예를 들면 인터페이스가 함수를 포혐하고 있다면 이것은 함수의 반환 형식과
매개변수들을 정의하고 있지, 실제로 구현하는 코드는 가지고 있지 않다. 인터페이스를
구현하고 있는 클래스는 메소드를 독자적으로 구현해야 한다.



[델리게이트(Delegate)]
델리게이트는 메소드를 참조하는 데이터 형식이다. C++의 함수 포인터와 비슷하나 인스턴스화되어
클래스의 정적 메소드와 클래스의 특정 인스턴스의 메소드들을 호출하는데 사용될 수있다.
그리고 델리게이트를 사용하면 실행 시에 어떤 메소드를 호출하고자 하는지 결정할 수 있다.


[배열(Array)]

C와 C++에서 배열은 단순히 메모리상의 어떤 주소를 가리키고 배열의 인덱스는 단순히
그 주소로부터의 offset을 나타내는 의미에 지나지 않았다. C나 C++에서는 배열을 배열
element에 대한 포인터를 이용하여 참조할 수 있는데, 첫번째 element의 주소값의 포인터에
element의 인덱스를 더하여 배열의 다른 element에 엑세스할 수 있다.

//C++에서는 이 대입문들이 둘 다 유효하고 동일하다.
a[100] = 1;
*(a+100) = 1;

이러한 방식을 사용하면 매우 유연하게 배열을 제어할 수 있을지 모르나 이에 필요한 포인터 연산은
오류를 발생시키기 쉽다. C와 C++는 배열의 크기를 점검하지 않기 떄문에 배열의 경계를 넘어서서 
메모리를 건드릴 수 있다. 그래서 프로그램이 잘못된 연산을 일으키는 경우가 많았다.

//C++에서 이것은 컴파일러가 검출해내지 못한다.
char *pString = new char[50];
pString[100] = '\0'l //100은 배열의 할당된 영역 안에 있지 않다.

이러한 C와 C++의 단점을 극복하기 위해 C#은 배열을 하나의 데이터 형식으로 명확히 정의하였다.
배열을 메소드와 프로퍼티를 가진 객체로 정의함으로써 CLR은 아웃 오브 바운드(out-of-bound, 배열의
크기를 넘어서 배열의 범위 밖의 메모리에 엑세스하여 일어나는 오류) 같은 오류를 사전에 방지할 수
있도록 지원한다. 더 나아가 C#은 프로그램 수행 중에 일어나는 아웃 오브 바운드 오류를 
자동으로 처리하기 위한 특별한 형식의 오류 객체를 제공한다.

[C# 배열의 문법]

C#은 배열에 대해서 독특한 엑세스 방식을 사용하고 있기 때문에 배열의 문법을 유일하게 지정하고 있다.
C 언어에서와 같이 배열을 각 element의 변수 형식의 끝에 대괄호를 열고 닫음으로써 선언할 수 있다.
(배열 안에 모든 element들은 동일한 데이터 형식을 가지고 있어야 한다.)
예를 들면 int는 단일 정수를 나타내는 반면 int[]는 정수의 배열을 나타낸다.

int[] Integers;

배열의 크기를 초기에 정해주고 싶으면 new 키워드를 이용하여 형식 이름 뒤에 대괄호를 쓰고
배열의 크기를 명시해줄 수 있다.

//32개의 정수를 가지는 새로운 배열을 만든다.
int[] Integers = new int[32];

배열 내의 element에 엑세스하기 위해서는 배열 이름 뒤에 대괄호를 쓰고 그 안에 element의
인덱스를 넣어주는 일반적인 문법을 사용한다. 모든 C#배열은 0 기반 인덱스를 사용하기 때문에
배열의 첫번째 element를 인덱스 0으로 참조할 수 있다.

Integers[0] = 35;

마찬가지로 마지막 element인 32번째 element는 31의 인덱스 값으로 참조할 수 있다.

Integers[31] 432;

C#의 배열 문법은 매우 유연하다. C#에서는 배열을 초기화하지 않고 선언할 수 있기 때문에
프로그램상에서 동적으로 크기를 변경할 수 있다. 그래서 기본적으로 null 참조를 만들어 new 키워드에
의해서 할당받은 메모리 영역을 가리키도록 지정할 수 있다.

int[] Integers;
Integers = new int[32];

이 문법은 maloc이나 sizeof를 사용하는 것보다 휠씬 쉽고, 우리가 이 문법을 사용하면 메모리 누수도
잘 일어나지 않는다. C나 C++에서는 배열에 의해 참조되는 메모리 영역이 특별히 해지되지 않는 한
힙에 그대로 남아 있었다. 반대로 C# 배열은 다른 C# 객체처럼 CLR에 의해서 관리되기 때문에,
더 이상 참조되지 않게 되면 자동으로 소멸된다.

C와 C++의 배열이 가진 장점은 중괄호를 통하여 배열의element의 값을 일일이 명시해 줄 수
있었다는 것이다. 다행이도 C#역시 이러한 간편함을 제공하고 있다.

string[] String = {"s1","s2","s3"};

이것 또한 같다.

string[] String = new string[] {"s1","s2","s3"};

하지만 이러한 방법으로 초기화를 하는 경우, 변수를 사용하여 배열의 크기를 명시하는 것은
불가능하며, 모든 형식에 대하여 위와 같은 방법을 사용할 수 있는 것은 아니다.

int len = 3;
//아래 명령문은 컴파일되지 않는다.
string[] String = new String[len] {"s1","s2","s3"};

하지만 상수는 사용할 수는 있다.

const int len = 3;
//허용된다.
string[] String = new String[len] {"s1","s2","s3"};

이 문법을 사용하여 실행 시에 배열의 크기를 결정할 수 없다. 만약 동적으로 크기가 할당되는
배열이나 실행 시에 확장될 수 있는 배열을 원한다면 ArrayList 객체의 인스턴스를 만들어야 한다.
이 객체는 System.Collections 네임스페이스 안에 정의되어 있는데 7장에서 자세히 다룰 것이다.

또한 배열 크기를 초월하여 element들의 값을 할당해 줄 수 없다.

//아래 명령문은 컴파일되지 않는다.
string[] String = new String[3]{"s1","s2","s3","s4"};


[배열로 작업하기]

배열은 C#에서 특별한 데이터 형식이기 때문에 예를 들면 배열의 크기를 알아내는 등 별도의
메소드를 가지고 있다. 그러므로 C#에서 작업하는 것은 매우 쉽다.

예를 들어 1차원 배열의 크기를 알아내기 위해서는 Length 프로퍼티를 사용하면 된다.

int ArrayLength = Integers.Length;

배열이 1차원 이상이라면 GetLength 메소드를 통하여 특정 차원의 크기를 구할 수 있다.

//첫번째 차원의 길이를 구한다.
int ArrayLength = integers.GetLength(0);

만약 배열이 element가 미리 정의된 형식의 일종이라면 Sort 메소드를 이용하여 배열을 
오름차순으로 정렬할 수 있다.

Array.Sort(String);

위에서 배열 인스턴스의 메소드가 아닌 Array 클래스의 정적 메소드를 호출한다는 것을 알아두자.
메소드의 매게변수로 정렬하고자 하는 배열을 넘겨주어야 한다.

다음 짤막한 프로그램은 유명한 예술가들의 이름을 문자열 배열로 저장하고 , 알바벳 반대
순서로 정력한 다음 각 이름을 콘솔 윈도우에 출력하는 예제이다.

//예술가의 이름들의 배열을 정의한다.
string[] Artists = {"Leonardo","Monet","Van Gogh","Kell"};


//배열 element들을 알파벳 순서로 정렬한다.
Array.Sort(Artists);

//배열을 내림차순으로 정렬한다.
Array.Reverse(Artists);

//각 element에 대해서 반복문을 수행하고 이름을 출력한다.
for(int i=0;i<Artists.Length;i++){
Console.WriteLine(Artists[i]);;
}



[C#의 다차원 배열]
C#은 두가지 방식으로 다차원 배열을 지원한다. 하나는 사각 배열이다. 2차원 사각 배열은
모든 행이 같으 개수의 열을 같는 것이다. 다음 예에서 설명하는 것같이 사각 배열은 상대적으로
선언하고 초기화하기 쉽다. 여기에서 각 행이 2개의 열을 가지고 있는 2차원 사각 배열을 선언해보자.


string[,] BeatleName = {{"Lennon","John"}
			,{"McCartney","Paul"}
			,{"Harrison","George"}
			,{"Starkey","Richard"}
			};


사각 배열을 선언할 때 차원을 구분하기 위해서 콤마를 사용하고 , 차원의 크기를 특별히 지정하지
않는다. 3차원 string 배열을 선언하기 위해 다음의 코드를 사용한다.

string[,,] Strings;

배열을 초기화하는 다른 방법은 다음과 같이 중첩된 for 문을 사용 하는 것이다.

double[,] Matrix = new double[10,10];
for(int i=0;i<10;i++){
	for(int j=0;j<10;j++){
	Matrix[i,j] = 4;
	}
}

C#이 지원하는 두번째 다차원 배열은 orthogonal('수직적'이라는 의미를 가지고 있다.) 혹은
소위 jagged('뾰족한'이라는 의미를 가지고 있는데 지그재그의 의미를 떠올리면 된다.) 배열이다.
jagged 이차원 배열의 각 행은 서로 다른 개수의 열을 가질 수 있다. 사각 배열보다 확실히 더
유연하지만 인스턴스를 만들고 초기화하기에는 어려움이 따른다. jagged 배열을 만들기 위해서
일단 배열의 배열을 만들어야 한다.

//jagged 배열을 만든다.
int[][] a = new int[3][];
a[0] = new int[4]
a[1] = new int[3];
a[2] = new int[1];

배열의 차원의 크기를 나타내기 위해서 콤마을 사용하지 않고 각 차윈에 대하여 대괄호 쌍
하나를 사용한다 그러므로 int 형식 변수의 3차원 jagged 배열을 선언하려면 다음과 깉이 한다.

int[][][] Ints;

jagged 배열의 element들을 탐색하는 것은 사각 배열의 element들을 탐삭하는 것보다 더 많은 일이
필요하다. 우선 각 행을 탐색하면서 그 행 안에 몇 개의 열이 있는지 알아내여 하는데,
배열의 GetLength 메소를 사용하면 된다.

//저자의 이름을 포함하는 2차원 배열을 선언한다.
string[][] Novelists = new string[3][];
Novelists[0] = new string[] {"Fyodor","Mikhailvoich","Dostoyevsky"};
Novelists[1] = new string[] {"James","Augustine","Joyce"};
Novelists[2] = new string[] {"Miguel","de Cervantes","Saavedra"};


//소트는 1차원 배열만 가능하다
Array.Sort(Novelists[0]);

//배열의 각 소설가들에 대해서 반복문을 수행한다.
int i;
	for (i = 0; i<Novelists.GetLength(0); i++) {
                int j;
                for (j = 0; j < Novelists[i].GetLength(0); j++) { 
                //현재 이름을 출력한다.
                    Console.WriteLine(Novelists[i][j]+" ");
                }
                //다음 소설가 이름은 새줄에서 시작한다.
                Console.WriteLine("\n");
            }



[형식 변환(Type Conversion)]

종종 데이터 형식끼리 변환해야 할 필요가 있다. 다음의 코드를 보자.

byte value1 = 10;
byte value2 = 23;
byte total;

// 두 바이트 값들이 더해지면 이것들은
// 암시적으로 int로 변환된다. 그래서
// 그결과를 byte로 다시 대입하는 것은
// 오류를 발생시킨다.
total = value1 + value2;  

Console.WriteLine(total);

위 코드를 컴파일하면 "Cannot implicitly convert type 'int' to 'bype'"라는 오류가 나온다,
문제는 byte 형식 변수 두 개를 더하면 결과는 byte가 아니라 int로  나온다는데 있다.
byte는 오직 8비트의 데이터(255까지)밖에 표함하지 못하기 때문에 두 개의 byte 값을 더하면
단일 바이트로는 저장할 수 없는 값이 나올 수 있다. 만약 이 결과를 byte 변수에 
저장하고자 한다면 컴파일러는 이것을 다시 byte로 변환할 것이다.
데이터 형식 변환에 있어서는 두가지 경우가 생길 수 있는데, 임시적으로 컴파일러가 
물어보지 않고 변환을 해주는 경우 혹은 명시적으로 우리가 컴파일러에게 어떤 값을 
다른 데이터 형식으로 변환시켜 달라고 요청하는 것이다.


[암시적 형식 변환(Implicit Type Conversion)]

데이터 형식 끼리의 변환은 값이 변하지 않는다는 보장이 있으면 자동으로 이루어질 수 있다.
예를 들면 short나 int 값은 아무런 문제없이 long 변수에 대입될 수 있다는 이야기이다. 
그리고 부호없는 변수의 값이 부호가 있는 변수의 한계값을 넘지 않았다면 부호가 없는 변수를
부호가 있는 변수에 할당해 줄 수 있다. 그리고 정수 형식에서 부동 소숫점 숫자 형식으로의
변환도 가능하다.

이것을 보면 왜 위의 코드가 컴파일에 실패했는지 알 수 있다. int에서 byte로 형식 변환하면
잠정적으로 3바이트의 데이터를 잃어버릴수 있다. 즉 프로그래머는 자신이 하고자 하는 변환을
명확히 명시해 주어야 하며, 그렇지 않으면 컴파일러는 오류를 발생시킨다.
만약 결과를 byte가 아니라 long 변수에 저장했다면 아무런 문자가 없었을 것이다.

왜냐하면 long이 int보다 더 많은 수의 바이트를 저장할 수 있어서 데이터를 잃어버릴 염려가
없기 때문이다. 이러한 상황이라면 컴파일러는 사용자가 굳이 데이터 형식 변환을 명시해
놓지 않아도 알아서 형식 변환을 해준다.

다음 표는 C#에서 가능한 암시적인 형식 변환의 경우를 보여준다.

-- 암시적 형식 변환 표
From  /  to
sbyte / short, int , long , float , double , decimal
byte  / short , ushort , int , uint, long , ulong , float , double , decimal
short  / int , long, double , decimal
ushort / int , uint , long , ulong , float , double , decomal
int    / long , float , double , decomal
uint   / long , ulong , float , double , decimal
long , ulong / float , double , decimal
float / double
char / ushort, int , uint , long , ulong , float , double , decimal

작은 정수 형식 변수에서 큰 정수 형식 변수로 혹은 부호가 없는 정수 형식을 동일한 크기를 가진
부호가 있는 정수 형식으로 암시적인 형식 변환을 할 수 있다는 것을 알 수 있다.
그 이외의 암시적인 형식 변환은 불가능하다. 그래서 uint와 int는 포함할 수 있는 수의 범위가 서로
달라서 형식 변환을 했을때 데이터를 잃어버릴 수 있으므로 서로 암시적으로 형식 변환될 수 없다.
하지만 uint가 포함할 수 있는 수의 범위가 long이 포함할 수 있는 수의 범위 안에 포함되므로 
uint는 long으로 형식 변환 될 수 있다. 그리고 정수 형식과 부동 소수점 숫자 형식 사이에 형식 변환을
할 수 있다. 뿐만 아니라 long/ulong을 다시 float로 형식 변환할 수 있고, long/ulong을 double로
형식 변환할 수 있다. 뿐만 아니라 long/ulong을 다시 float로 형식 변환할 수 있다.
long/ulong 형식의 변수를 float로 형식 변환하면 4바이트의 데이터를 잃어버린다고 생각할 수도 있지만
형식 변환되어 얻어지는 float의 값은 double로 형식 변환했을 때보다 소수점 아래의 값은 덜 정확할지
모르지만 값의 크기는 변하지 않는다. float에서 double로 형식 변환하는 것은 부호가 있는
정수 형식의 경우와 똑같은 규칙을 따른다.


[명시적 형식 변환(Explicit Type Conversion)]

데이터 형식들 사이에 암시적으로 이루어질 수 없거나 컴파일러가 오류로 인식하는 형 변환의
경우가 많이 있다. 다음은 암시적으로는 이루어질 수 없는 형식 변환의 예이다.

-int에서 short로 : 데이터를 잃어버릴 수 있다.
-int 에서 unit로 : 데이터를 잃어버릴 수 있다.
-uint 에서 int로 : 데이터를 잃어버릴 수 있다.
-float 에서 int로 : 소수점 아래의 모든 값을 잃어버릴 수 있다.
-어떤 숫자 데이터 형식에서 char로 : 데이터를 잃어버릴 수 있다.
-decimal에서 다른 숫자 데이터 형식으로 : decimal 데이터 형식이 내부적으로 정수 형식이나
					 실수 형식과는 다르게 구성되어 있기 떄문에 불가


그러나 캐스트를 이용하여 이러한 형식 변환을 명시적으로 수행할 수 있다. 어떤 데이터 
형식을 다른 데이터 형식으로 캐스트 한다는 것은 강제로 형식 변환하는 것을  의미한다.
즉 프로그래머는 캐스트를 통하여 강제적인 형식 변환을 컴파일러에게  알려주는 것이다.
캐스트의 일반 적인 문법은 다음과 같다.

long val = 30000;
int i = (int)val; // 유효한 캐스트, 최대 int 값은 2147483647

C에서 흔히 사용하ㄷ던 캐스트의 문법이다. static_cast와 같이 C++에서 사용하는 캐스트
키워드들은 C#에는 정의되어 있지 않기 떄문에 반드시 이 문법을 사용해야 한다.

이러한 형식 변환은 오류를 발생시킬 수 있기 때문에 어떤 기능을 하는지 정확히 알고
사용해야 한다. 단순히 long에서 int로 캐스트 했다고 하더라도 long 형식 변수의 원래 값이
int 형식의 최대값보다 큰 값이었다면 그러한 캐스트는 문제를 일으 킬 수 있다.

만약 다음의 코드를 실행시키면,

long val = 30000000000;
int i = (int)val; // 유효하지 않은 캐스트, 최대 int 값은 2147483647


이러한 경우에 오류는 발생하지 않지만 예상치 못한 결과를 초래한다. 만약 위의 코드를 실행시키면
i에 최종적으로 저장되는 값은 -64771072 이다.

절대로 캐스트가 항상 제대로 된 결과를 만들어낸다고 생각하면 안된다. C#에서는 checked라는
연산자를 제공하는데 , 이를 이용하면 연산 도중 발생할 수 있는 스택 오버플로우를 검사할 수 있다.
이 연산자를 이용하여 이 캐스트가 안전한지 그리고 실행 시에 오버플로우 예외를 발생시키지는
않는지 등을 점검할 수 있다.


long val = 30000000000;
int i = checked((int)val);

모든 캐스트를 이용하여 대부분의 데이터 형식을 다른 데이터 형식으로 변환할 수 있다.
예를 들면 다음과 같다.

double price = 25.30;
int approximatePrice = (int)(price+0.5);

이 코드를 통해여 price값을 소수점 아래에서 반올림한 값을 얻을 수 있다. 이러한 경우에서는
소수점 아래의 모든 데이터를 잃어버리게 된다. 그래서 이러한 형식 변환은 변환된 price값을 사용하여
더 많은 계산을 하고자 하는 경우에는 절대 사용하지 않도록 한다. 하지만 소수점 아래의 
복잡한 데이터를 모두 절삭하고 정수 형식에 가까운 근사치를 얻고자 할 때는 유용하게 쓰인다.

이 예는 부호가 없는 정수 형식을 char로 형식 변환했을 때를 보여준다.

ushort c = 43;
char symbol = (char) c;
Console.WriteLing(symbol);

출력으로 나오는 것은 아스키값 43의 문자인 +기호이다. 원한다면 이렇게 char를 포함하여 
숫자 데이터 형식끼리 형식 변환을 할 수 있고 decimal과 char끼리 형식 변환을 하였을 때처럼
재밌는 결과가 나올 수 있다.

decimal d = 65m;
char symbol = (char) d;  // A가 나온다

char c  = 'A';
decimal val = (decimal) c ; //65가 나온다.

하지만 캐스트 연산에 의해서 얻어지는 결과값이 새로운 데이터 형식에 맞춰질 수 없는 값이라면
이 캐스트는 오류를 일으키지 않지만 기대하던 결과값과는 틀린린 값을 만들어 낸다. 
다음의 예를 보자.

int i = -1;
char symbol = (char) i ;


char 형식은 음수를 가질 수 없기 때문에 이 캐스트는 동작하지 않는다. 하지만 오류는 발생하지
않고 대신 물음표가 대입된다.

값 형식끼리 변환하는 것은 지금까지 봐 왔던 것처럼 독립적인 변수에만 제한되어 있는 것은 아니다.
double 형식의 배열 element를 int 형식의 구조체 멤버 변수로 변환할 수 있다.


struct ItemDetails
{
  public string Description;
  public int ApproxPrice;
}
.....

double[] Prices = { 25.30 , 26.20 , 27.40 , 30.30 };

ItemDetail id;
id.Description = "Whatever";
id.ApproxPrice = (int)(Prices[0]+0.5);


명시적인 캐스트를 신중하게 잘 사용하면 간단한 값 형식의 인스턴스를 다른 데이터 
형식으로 변환할 수 있다. 하지만 값 형식에 관해서는 명시적으로 형식 변환할 수 있는 데
제약이 존재한다. 오직 숫자 형식과 char 형식과 enum 형식끼리만 형식 변환할 수 있고 부울 형식과
다른 데이터 형식 사이에는 직접 캐스트할 수 없다.

예를 들어 숫자 데이터 형식과 문자열 사이에 변환을 하고 싶다면 .NET 클래스 라이브러리에
정의된 메소드를 이용하면 된다. object 클래스는 ToString()이라는 메소를 가지고 있고 모든
다른 클래스는 이것을 구현해야 한다. 이 메소드는 객체의 문자열 표현을 반환하기 떄문에
다음의 코드를 이용하여 int를 string으로 변환할 수 있다.

int i = 10;
string s = i.ToString();

비슷하게 문자열을 숫자 형식이나 부울값으로 바꾸고 싶으면 모든 미리 정의된 값 형식이
지원하는 Parse 메소드를 사용하면 된다.

string s = "100";
int i = int.Parse(s);
Console.WriteLine(i+50);  //int임을 증명하기 위해서 50을 더한다.















































