[CTS 형식]
VB가 그렇게 생산적인 언어가 될 수 있었던  이유는 다른 언어에 비해서 상대적으로
풍부한 데이터 형식들을 제공했기 때문이다. VB는 실무 프로그래밍에 유용한
문자열 형식 , 부울 형식 , 날짜/시간에 관련된 데이터 형식 등 아주 많은 데이터
형식을 제공한다. 이것은 저수준의 C나 C++ 같은 언어와 비교해 볼 때 대조되는
측면이다. C와 C++ 같은 언어에서 이러한 데이터 형식을 사용하려면 개발자가
여러 가지 형식들을 클래스나 구조체에 넣어 새로운 데이터 형식을 정의하거나,
헤더 파일에 정의된 복잡한 템플릿 라이브러리(예를들어 STL)를 사용하거나,
MFC와 같이 복잡하고 비효율적인 라이브러리를 사용해야 한다

다른 .NET 언어와 같이 C#에서는 CTS(Common Type System)라는 것을 지원하여
int , float , char와 같은 기본적인 데이터 형식 이외에 string 형식이나
통화에 관련된 값을 계산하기 위한 decimal 형식 등 다소 복잡한 데이터 형식을 
간편하게 사용할 수 있다. 더 나아가 각각의 데이터 형식들은 단순히 기본 데이터 형식으로
그치는 것이 아니라 , 데이터의 형식을 변환하고 직렬화하는 등의 기능도 제공한다.


-요점-
C#에서는 CTS(Common Type System)을 지원하여
기본적인 데이터 형식 이외의 string 등 다소 복잡한 데이터 형식을 
간편하게 사용가능 , 더 나아가 각각의 데이터 형식들은  기본 데이터 형식으로
그치는 것이 아니라, 데이터의 형식을 변환하고 직렬화 하는 기능도 제공


=================================================================================

[형식 안전성]
몇 년 전에 우주로 향하던 로켓이 출발한 뒤 몇 분이 채 지나지 않아 폭발하여
NASA에 어마어마한 손해를 입힌 적이 있다. 그 원인을 조사한 결과 소프트웨어적인
오류에 의해서 일어난 사고였다. 그 오류는 프로그래머가 실수로 이중 ==이
필요한 곳에 =을 넣은 C 코드의 버그 때문이었다. 이렇게 되면 실제의 비교
구문에서는 false 값이 나와야 하는 곳에서 ture 값이 나올수 있다.
결국 C는 형식 안전성을 보장하지 못한다.

로켓을 폭파시킬 만큼 치명적인 오류를 경험해 보진 못하더라도 C나 C++를
이용하여 코딩을 하다보면 위와 같은 실수는 괘 자주 일어난다.
이러한 오류는 찾아내기가 힘들다. 디버깅에서 한 줄 한 줄씩 실행 과정을
추적하면서 문제를 일으킬 수 있는 형식 변환 구문들을 하나씩 찾아가
보아야만 겨우 발견할 수 있다. 문제를 일으킬 수 있고 확실하지 않은 형식 변환
구문은, 예를 들면 C++에서 int로 정의된 4바이트 정수형 변수를 short로 정의된
2바이트 정수형 변수에 대입을 하는 코드 같은 것이다. 만일 int 형식의 변수가
2바이트를 초과하는 범위의 값을 가지고 있다면, 2바이트 short 형식의
변수가 가지는 값은 개발자가 의도하지 않은 엉뚱한 값을 지니게 된다.
이러한 실수는 매우 중요한 프로그램을 짜는 경우에 있어서는 더이상 용납될 수 었다.

C#은 매우 엄격하게 형식화 된 언어이다. 예를 들어, 부울 형식(bool)은 자동으로
정수 형식(int)으로 변환될 수 없다. 만일 구렇게 변환하고 싶다면 명시적인
형식 변환 연산자를 통하여 할 수 있다.
이것에 관해서는 나중에 좀더 자세하게 알아볼 것이다.

그리고 C#에서는 사용자가 직접 만든 데이터 형식이 명시적 형식 변환
혹은 암시적 형식 변환에 의해서 어떻게 작동하는지 정의해 줄 수 있다.
이러한 형식 변환에 관련된 자세한 사항은 6장에서 다룰것이다.



=================================================================================

[값 형식과 참조 형식]

C# 프로그램의 데이터 형식은 그 형식의 특성에 따라서 하나 혹은 두 가지 장소에 저장된다.

첫번째 장소는 스택(stack)이다. 여기는 int 형식(int 형식은 4바이트의 크기를 가지고 있다.)
같이 고정된 크기를 갖는 데이터를 저장하는데 사용된다. 모든 프로그램은 다른 프로그램이
침범 할수 없는 독자적인 스택을 가지고 있다. 메소드가 호출될 때 그 메소드 내에 모든 지역
변수는 스택에 보관되어 사용된다. 무한 재귀적 호출을 수행하는 프로그램을 작성하여
실행시키다가 "스택 공간이 모자랍니다."라는 오류를 본 적이 있을 것이다.
이것은 너무 많은 변수들을 스택에 쌓아놓아서 스택 공간이 부족했기 때문이었다는 것을 알아두자.


-정리-
1.스택(stack)

-여기는 int형식 같이 고정된 크기를 갖는 데이터를 저장하는데 사용된다.
-모든 프로그램은 다른 프로그램이 침범 할수 없는 독자적인 스택을 가지고 있다.
- 메소드가 호출될 때 그 메소드 내에 모든 지역 변수는 스택에 보관되어 사용한다.
-무한 재귀적 호출을 수행하는 프로그램을 작성하여 실행시키다가 
"스택공간이 모자랍니다."라는 오류는 너무 많은 변수들을 스택에 쌓아놓아서
스택 공간이 부족했기 때문이다.

두번째 장소는 힙(heap)이다. C나 C++ 같은 예전의 언어에서는 힙을 문자열 같이
동적인 크기를 가진 데이터를 저장하는데 사용하거나 , 그 데이터가 처음 정의된
메소드의 범위를 넘서도 계속 유효한 데이터를  저장하고 있도록 하기 위해서 사용하였다.
메소드가 시스템의 힙에 객체를 생성하면, 메소드 호출이 끝나더라도 시스템은 그 객체를
제거하지 않는다. C#에서는 이러한 경우에 관리 힙(managed heap)이라고 하여 기존의 힙과는
약간 다른 성격을 가진 공간에 저장한다. 관리 힙은 목적상으로는 기존의 힙과 비슷하지만
내부적으로는 좀더 효율적으로 작동한다. 그리고 예전에 언어에서는 개발자가 주어진
객체에 대해서 힙을 사용할 것을 명시해줄수 있었지만 , C#에서는 컴파일러가 객체의
데이터 형식에 따라 모든 것을 결정 한다.

C#은 데이터가 저장되는 장소에 따라 데이터 형식을 두 가지 범조로 나눈다.
값 형식(Value Type) 과 참조 형식 (reference type)이 바로 그것이다.
간단하게 이야기하면 값 형식 변수는 데이터를 스택에 저장하고 , 
참조 형식 변수는 데이터를 힙에 저장한다. 5장에서 이 두가지 데이터 형식에 
관해 좀더 자세히 살펴볼 것이다.

데이터 형식이 저장되는 장소는 그 데이터 형식을 가진 변수가 할당되는 방식을 내포하고 있다.
하나의 값 형식 변수를 다른 값 형식 변수에 대입하는 것은 같은 데이터의 복사본을 스택내에
만드는 것을 의미한다. 반대로 하나의 참조 형식 변수를 다른 참조 형식 변수에 대입하는 것은
메모리의 동일한 위치를 두 변수가 가리키게 되는 것을 의한다.


C#에서 bool이나 long 같은 기본적인 데이터 형식은 값 형식이다.
만약 부울 변수를 하나 선언하고 거기에 다른 부울 변수의 값을 대입하면 
두개의 독립적인 부울 변수를 메모리에 생성하게 된다.
나중에 첫번째 부울 변수의 값을 변화시키더라도 두번째 부울 변수의 값은 바뀌지 않는다.
이러한 형식의 변수들에서는 값이 복사된다.

반대로, 클래스를 포함하여 C#의 복잡한 데이터 형식은 대부분 참조 형식이다.
참조 형식의 변수는 힙에 할당되고, 코드의 여러 군데에서 오랫동안 유효한 값을 지니게 되고
하나 혹은 다수의 참조 형식 변수에 의해서 엑세스 가능하다. CLR은 어떤 참조 형식의 변수가
참조하던 개체가 더 이상 엑세스 가능하지 않으면 그 객체에 할당된 메모리를 해지시켜 준다.
CLR의 이러한 기능을 가리켜 '가비지 컬렉션(garbage collection)'이라 부른다.

bool이나 long 같은 값 형식이 다수의 메소드를 제공한다는 점에서 클래스와 같이
생각될 수도 있지만 사실 그것들은 구조체이다. C#에서 구조체 형식도 값 형식인 것이다.
구조체 형식은 스택에 만들어지고 대입 구문에서 복사를 수행한다는 차원에서
엄연히 값 형식이다.

C# 내의 변수들이 대입 문장에서 어떻게 행동하는지 이해하기 위해서는  값 형식과 참조 형식
의 차이점을 잘 이해할 필요가 있다. 이 두 가지 형식이 어떠한 차이점을 가지며 동작하는지
살펴보자.

Width와 Height라는 두 필드를 가지는 RefTypeRectangle 이라는 이름의 클래스를 하나
만들것이다. 아 클래스를 생성한 다음 앞의 두 필드를 초기화하고, 객체의 복사복을 만든다.
그리고 원복 객체가 가진 필드의 값을 변화시켜 볼 것이다.
원본 객체가 가진 필드의 값을 변화시킨에 따라 복사본이 가진 필드의 값이 어떻게 
변하는지 실펴보자. 그리고 RefTypeRectangle 클래스와 모든 면에서 동인할 ValTypeRectangle
라는 구조체를 하나 정의하여 구조체 형식이 참조 형식이 아니라 값 형식이라는 것을 확인하도록 하자.

원본 클래스의 필드 값을 변화시켰을 때 어떻게 복사본의 필드 값도 함꼐 바뀌도록 했는지 확인하자.
클래스는 참조 형식이라서 두 변수 rect1, rect2는 객체가 저장된 메모리의 동일한 장소를 참조하고 있다.
그래서 원본 클래스의 필드 값의 변화에 따라 복사본의 필드 값도 함께 바뀐다.
하지만 두 구조체는 위와 정반대로 행독한다. 구조체는 값 형식이므로 두번쨰 구조체를 선언하고
첫번째 구조체로 초기화하면 독립적인 메모리 공간에 두번째 구조체가 생성된다.
그러므로 첫번째 구조체의 값을 바꾸어도 두번째 구조체에서는 아무런 영향을 끼치지 않는다.

이러한 결과는 왜 두 가지의 다른 데이터 형식이 필요한가에 관한 단서를 제공해준다.
정수 형식과 같은 기본 데이터 형식의 변수를 복사하거나 이것을 함수로 전달할 때에는 단순히 값을
복사해 주기만 하면 되지 굳이 참조하도록 할 필요는 없다. 특히 정수 형식 변수가 필요할 때마다
힙에 객체를 만들어주도록 하면 너무 번거롭다. 하지만 꽤 덩치가 큰 객체를 다룰 때에는 객체의
전체적인 부분을 복사하는 것보다 객체에 대한 참조만 복사하도록 하는 것이 휠씬 더 효율적이다.
예를 들면 구조체를 메소드의 인수로 전달하는 경우에는 구조체 내의 모든 데이터가 복사되고
새로운 구조체가 스택에 할당된다. 이러한 이유 때문에 구조체를 쓸 때는 항상 신중하게 생각해야 하며,
구조체를 단순한 데이터 형식의 모음으로만 생각하여 사용해야 한다.
구조체를 전달할 때 참조만 복사하도록 전달하면 객체를 생성하는 부담을 줄여주므로 성능을 매우
향상시킬 수 있다.

결론적으로 C#의 구조체는 클래스와 매우 비슷하다. 하지만 클래스는 참조 형식이고 구조체는
값 형식이란 근본적인 차이점을 잊지 말자.





































