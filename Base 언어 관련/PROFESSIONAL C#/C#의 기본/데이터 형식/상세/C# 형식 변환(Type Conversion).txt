[형식 변환(Type Conversion)]

종종 데이터 형식끼리 변환해야 할 필요가 있다. 다음의 코드를 보자.

byte value1 = 10;
byte value2 = 23;
byte total;

// 두 바이트 값들이 더해지면 이것들은
// 암시적으로 int로 변환된다. 그래서
// 그결과를 byte로 다시 대입하는 것은
// 오류를 발생시킨다.
total = value1 + value2;  

Console.WriteLine(total);

위 코드를 컴파일하면 "Cannot implicitly convert type 'int' to 'bype'"라는 오류가 나온다,
문제는 byte 형식 변수 두 개를 더하면 결과는 byte가 아니라 int로  나온다는데 있다.
byte는 오직 8비트의 데이터(255까지)밖에 표함하지 못하기 때문에 두 개의 byte 값을 더하면
단일 바이트로는 저장할 수 없는 값이 나올 수 있다. 만약 이 결과를 byte 변수에 
저장하고자 한다면 컴파일러는 이것을 다시 byte로 변환할 것이다.
데이터 형식 변환에 있어서는 두가지 경우가 생길 수 있는데, 임시적으로 컴파일러가 
물어보지 않고 변환을 해주는 경우 혹은 명시적으로 우리가 컴파일러에게 어떤 값을 
다른 데이터 형식으로 변환시켜 달라고 요청하는 것이다.


[암시적 형식 변환(Implicit Type Conversion)]

데이터 형식 끼리의 변환은 값이 변하지 않는다는 보장이 있으면 자동으로 이루어질 수 있다.
예를 들면 short나 int 값은 아무런 문제없이 long 변수에 대입될 수 있다는 이야기이다. 
그리고 부호없는 변수의 값이 부호가 있는 변수의 한계값을 넘지 않았다면 부호가 없는 변수를
부호가 있는 변수에 할당해 줄 수 있다. 그리고 정수 형식에서 부동 소숫점 숫자 형식으로의
변환도 가능하다.

이것을 보면 왜 위의 코드가 컴파일에 실패했는지 알 수 있다. int에서 byte로 형식 변환하면
잠정적으로 3바이트의 데이터를 잃어버릴수 있다. 즉 프로그래머는 자신이 하고자 하는 변환을
명확히 명시해 주어야 하며, 그렇지 않으면 컴파일러는 오류를 발생시킨다.
만약 결과를 byte가 아니라 long 변수에 저장했다면 아무런 문자가 없었을 것이다.

왜냐하면 long이 int보다 더 많은 수의 바이트를 저장할 수 있어서 데이터를 잃어버릴 염려가
없기 때문이다. 이러한 상황이라면 컴파일러는 사용자가 굳이 데이터 형식 변환을 명시해
놓지 않아도 알아서 형식 변환을 해준다.

다음 표는 C#에서 가능한 암시적인 형식 변환의 경우를 보여준다.

-- 암시적 형식 변환 표
From  /  to
sbyte / short, int , long , float , double , decimal
byte  / short , ushort , int , uint, long , ulong , float , double , decimal
short  / int , long, double , decimal
ushort / int , uint , long , ulong , float , double , decomal
int    / long , float , double , decomal
uint   / long , ulong , float , double , decimal
long , ulong / float , double , decimal
float / double
char / ushort, int , uint , long , ulong , float , double , decimal

작은 정수 형식 변수에서 큰 정수 형식 변수로 혹은 부호가 없는 정수 형식을 동일한 크기를 가진
부호가 있는 정수 형식으로 암시적인 형식 변환을 할 수 있다는 것을 알 수 있다.
그 이외의 암시적인 형식 변환은 불가능하다. 그래서 uint와 int는 포함할 수 있는 수의 범위가 서로
달라서 형식 변환을 했을때 데이터를 잃어버릴 수 있으므로 서로 암시적으로 형식 변환될 수 없다.
하지만 uint가 포함할 수 있는 수의 범위가 long이 포함할 수 있는 수의 범위 안에 포함되므로 
uint는 long으로 형식 변환 될 수 있다. 그리고 정수 형식과 부동 소수점 숫자 형식 사이에 형식 변환을
할 수 있다. 뿐만 아니라 long/ulong을 다시 float로 형식 변환할 수 있고, long/ulong을 double로
형식 변환할 수 있다. 뿐만 아니라 long/ulong을 다시 float로 형식 변환할 수 있다.
long/ulong 형식의 변수를 float로 형식 변환하면 4바이트의 데이터를 잃어버린다고 생각할 수도 있지만
형식 변환되어 얻어지는 float의 값은 double로 형식 변환했을 때보다 소수점 아래의 값은 덜 정확할지
모르지만 값의 크기는 변하지 않는다. float에서 double로 형식 변환하는 것은 부호가 있는
정수 형식의 경우와 똑같은 규칙을 따른다.


[명시적 형식 변환(Explicit Type Conversion)]

데이터 형식들 사이에 암시적으로 이루어질 수 없거나 컴파일러가 오류로 인식하는 형 변환의
경우가 많이 있다. 다음은 암시적으로는 이루어질 수 없는 형식 변환의 예이다.

-int에서 short로 : 데이터를 잃어버릴 수 있다.
-int 에서 unit로 : 데이터를 잃어버릴 수 있다.
-uint 에서 int로 : 데이터를 잃어버릴 수 있다.
-float 에서 int로 : 소수점 아래의 모든 값을 잃어버릴 수 있다.
-어떤 숫자 데이터 형식에서 char로 : 데이터를 잃어버릴 수 있다.
-decimal에서 다른 숫자 데이터 형식으로 : decimal 데이터 형식이 내부적으로 정수 형식이나
					 실수 형식과는 다르게 구성되어 있기 떄문에 불가


그러나 캐스트를 이용하여 이러한 형식 변환을 명시적으로 수행할 수 있다. 어떤 데이터 
형식을 다른 데이터 형식으로 캐스트 한다는 것은 강제로 형식 변환하는 것을  의미한다.
즉 프로그래머는 캐스트를 통하여 강제적인 형식 변환을 컴파일러에게  알려주는 것이다.
캐스트의 일반 적인 문법은 다음과 같다.

long val = 30000;
int i = (int)val; // 유효한 캐스트, 최대 int 값은 2147483647

C에서 흔히 사용하ㄷ던 캐스트의 문법이다. static_cast와 같이 C++에서 사용하는 캐스트
키워드들은 C#에는 정의되어 있지 않기 떄문에 반드시 이 문법을 사용해야 한다.

이러한 형식 변환은 오류를 발생시킬 수 있기 때문에 어떤 기능을 하는지 정확히 알고
사용해야 한다. 단순히 long에서 int로 캐스트 했다고 하더라도 long 형식 변수의 원래 값이
int 형식의 최대값보다 큰 값이었다면 그러한 캐스트는 문제를 일으 킬 수 있다.

만약 다음의 코드를 실행시키면,

long val = 30000000000;
int i = (int)val; // 유효하지 않은 캐스트, 최대 int 값은 2147483647


이러한 경우에 오류는 발생하지 않지만 예상치 못한 결과를 초래한다. 만약 위의 코드를 실행시키면
i에 최종적으로 저장되는 값은 -64771072 이다.

절대로 캐스트가 항상 제대로 된 결과를 만들어낸다고 생각하면 안된다. C#에서는 checked라는
연산자를 제공하는데 , 이를 이용하면 연산 도중 발생할 수 있는 스택 오버플로우를 검사할 수 있다.
이 연산자를 이용하여 이 캐스트가 안전한지 그리고 실행 시에 오버플로우 예외를 발생시키지는
않는지 등을 점검할 수 있다.


long val = 30000000000;
int i = checked((int)val);

모든 캐스트를 이용하여 대부분의 데이터 형식을 다른 데이터 형식으로 변환할 수 있다.
예를 들면 다음과 같다.

double price = 25.30;
int approximatePrice = (int)(price+0.5);

이 코드를 통해여 price값을 소수점 아래에서 반올림한 값을 얻을 수 있다. 이러한 경우에서는
소수점 아래의 모든 데이터를 잃어버리게 된다. 그래서 이러한 형식 변환은 변환된 price값을 사용하여
더 많은 계산을 하고자 하는 경우에는 절대 사용하지 않도록 한다. 하지만 소수점 아래의 
복잡한 데이터를 모두 절삭하고 정수 형식에 가까운 근사치를 얻고자 할 때는 유용하게 쓰인다.

이 예는 부호가 없는 정수 형식을 char로 형식 변환했을 때를 보여준다.

ushort c = 43;
char symbol = (char) c;
Console.WriteLing(symbol);

출력으로 나오는 것은 아스키값 43의 문자인 +기호이다. 원한다면 이렇게 char를 포함하여 
숫자 데이터 형식끼리 형식 변환을 할 수 있고 decimal과 char끼리 형식 변환을 하였을 때처럼
재밌는 결과가 나올 수 있다.

decimal d = 65m;
char symbol = (char) d;  // A가 나온다

char c  = 'A';
decimal val = (decimal) c ; //65가 나온다.

하지만 캐스트 연산에 의해서 얻어지는 결과값이 새로운 데이터 형식에 맞춰질 수 없는 값이라면
이 캐스트는 오류를 일으키지 않지만 기대하던 결과값과는 틀린린 값을 만들어 낸다. 
다음의 예를 보자.

int i = -1;
char symbol = (char) i ;


char 형식은 음수를 가질 수 없기 때문에 이 캐스트는 동작하지 않는다. 하지만 오류는 발생하지
않고 대신 물음표가 대입된다.

값 형식끼리 변환하는 것은 지금까지 봐 왔던 것처럼 독립적인 변수에만 제한되어 있는 것은 아니다.
double 형식의 배열 element를 int 형식의 구조체 멤버 변수로 변환할 수 있다.


struct ItemDetails
{
  public string Description;
  public int ApproxPrice;
}
.....

double[] Prices = { 25.30 , 26.20 , 27.40 , 30.30 };

ItemDetail id;
id.Description = "Whatever";
id.ApproxPrice = (int)(Prices[0]+0.5);


명시적인 캐스트를 신중하게 잘 사용하면 간단한 값 형식의 인스턴스를 다른 데이터 
형식으로 변환할 수 있다. 하지만 값 형식에 관해서는 명시적으로 형식 변환할 수 있는 데
제약이 존재한다. 오직 숫자 형식과 char 형식과 enum 형식끼리만 형식 변환할 수 있고 부울 형식과
다른 데이터 형식 사이에는 직접 캐스트할 수 없다.

예를 들어 숫자 데이터 형식과 문자열 사이에 변환을 하고 싶다면 .NET 클래스 라이브러리에
정의된 메소드를 이용하면 된다. object 클래스는 ToString()이라는 메소를 가지고 있고 모든
다른 클래스는 이것을 구현해야 한다. 이 메소드는 객체의 문자열 표현을 반환하기 떄문에
다음의 코드를 이용하여 int를 string으로 변환할 수 있다.

int i = 10;
string s = i.ToString();

비슷하게 문자열을 숫자 형식이나 부울값으로 바꾸고 싶으면 모든 미리 정의된 값 형식이
지원하는 Parse 메소드를 사용하면 된다.

string s = "100";
int i = int.Parse(s);
Console.WriteLine(i+50);  //int임을 증명하기 위해서 50을 더한다.


