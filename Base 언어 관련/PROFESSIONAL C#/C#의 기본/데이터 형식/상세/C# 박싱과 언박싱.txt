[박싱(Boxing)과 언박싱(UnBoxing)]

우리는 지금까지 int나 char와 같이 단순히 미리 정의된 데이터 형식을 비롯하여 클래스나
구조체와 같은 복잡한 데이터 형식들이 object 형식에서 파생된다는 것을 보았다. 이것은
리터럴 값까지도 객체처럼 다룰 수 있다는 것을 의미한다.

string s = 10.ToString();

C#의 데이터 형식은 값 형식과 참조 형식으로 나뉘는데 값 형식은 스택에 할당되어 데이터를
저장하고 있고 참조 형식은 미리 결정된 크기를 가지고 있는 것이 아니고 힙에 할당된다.
그렇다면 만약에 int가 스택에 저장된 단순한 4바이트의 값에 지나지 않는다면 우리는 어떻게
int의 메소드를 호출할 수 있을까?

이것은 박싱이라는 다소 마법 같은 것을 통하여 이루어진다. 박싱(boxing)을 통하여 값 형식을
참조 형식으로 변환하고 언박싱(unboxing)을 통하여 참조 형식을 값 형식으로 변환한다.
이것은 값 형식을 object 형식으로 캐스트하는 것과 같다. 박싱은 값 형식을 참조으로 변환하는
것을 표현하기 위한 용어이다. 기본적으로 런타임은 힙의 객체에 대해서 일시적인 참조
형식인 "박스(Box)"를 만든다.

이 변환은 앞의 코드에서처럼 암시적으로 이루어질 수 있으나 다음과 같이 수행될 수도 있다.

int i = 20;
object o = i;

언박싱(unboxing)은 반대로 참조 형식이 값 형식으로 변환되는 과정을 나타낸다. 이것은
명시적으로 행해져야 하기 때문에 캐스트라는 말을 사용한다.문법은 위에서 언급한 명시적인
형식 변환에 사용되는 것과 같다.


int i = 20;
object o = i; //int를 박싱한다.
int j = (int)o; //이것을 다시 int로 언박싱한다.


그리고 이전에 박싱된 변수만 언박싱시킬 수 있다.

한가지 유의할 점은 언박싱을 할 때 언박싱한 값이 대입될 데이터 형식이 언박싱할 데이터 형식의
원래의 바이트값을 모두 저장할 수 있어야 한다는 것이다. 예를 들면 C#의 int는 32비트의
길이를 가지고 있는데 64비트인 long 값을 언박싱해서 int로 대입하는 것은 오류를 일으키게 된다.
다음의 코드를 보자.


long a = 333333423; //a는 스택에 저장된 지역 long이다.
object b = (object) a;  //b는 a의 박스가 힙에 저장된 곳을 가리키는 참조 형식 변수이다.
int c = (int)b;  // 오류 : long 변소는 int로 언박싱된다.

여기에서는 a가 가진 64비트 길이의 long 값이 힙에 박싱되고, 32비트 길이의 int 변수에
언박싱 된다. 힙의 어떤 값을  값 형식 변수로 언박싱하는 것은 실행 시에 오류를 발생시키게 된다.
실행 시에 어떤 데이터 형식의 변수를 다른 데이터 형식으로 언박싱하여 오류를 일으키지 않도록
하려면 값 형식 변수를 박싱할 때 변수의 원래 데이터 형식을 기억하고 있어야 한다.















