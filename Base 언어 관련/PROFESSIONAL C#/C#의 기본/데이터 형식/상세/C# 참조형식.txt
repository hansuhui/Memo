[참조 형식]

C#은 매우 제한적인 포인터 사용만을 허용한다고 이야기했다. 그렇다면 C# 프로그래머는 어떻게
힙 안의 객체를 조작할 수 있을까? 우리가 Something이라는 클래스를 가지고 있다고 가정하고
다음의 코드를 살펴보자.

Something objSomething;

C++에서 위 코드는 Something 클래스의 인스턴스를 스택에 생성하고, objSomething으로
그것을 참조시킨다. C#에서 이 코드는 아직 초기화되지 않은 Something의 참조를 만든다.
초기화되지 않은 null 참조를 통하여 이 객체에 엑세스하려고 시도하면 오류가 발생한다.

C#의 참조 객체 인스턴스는 new 키워드를 사용하여 생성한다. C#에서는 참조를 하나 만든
다음 new 키워드에 의해 힙에 할당된 객체를 참조가 가리키게 지정한다.

Something objSomething;  // 이 참조는 어떤 것도 가리키고 있지 않다.
objSomething = new Something //이것은 Something을 힙에 초기화 한다.


C#은 다음 두가지의 미리 정의된 참조 형식을 지원한다


이름    /     CTS형식	/ 설명
object / System.Object / 값 형식을 포함한 CTS의 모든 데이터 형식이 파생되는 근본 형식
string / System.String / 유니코드 문자열


[Object 형식]

많은 프로그래밍 언어와 클래스 계층은 다른 모든 객체가 파생되는 근본 형식을 우선 정의하고 있다.
C#과 .NET도 예외가 아니다. C#에서는 object 형식이라는 것이 그러한 역할을 한다.

어떤 객체를 다른 특정한 서브 형식으로 바꿀 때 object 참조를 쓴다. 예를 들면 스택의 값 형식
객체를 힙으로 옮기려면 값 형식 객체를 박싱(boxsing, 여기서 박싱이라는 것은 값 형식을 
참조 형식으로 바꾸는 것을 의미한다)해야 하는데, 이를 위해 object 형식이 사용된다. 코드가 형식을
알 수 없는 객체를 조작해야 할 떄가 있는데 객체 참조는 리플렉션(reflection:반사)에 있어서도 
매우 유용하게 쓰인다.

그리고 object 형식은 Equal(), GetHashCode() , GetType() , ToString() 같이 기본적이고
일반적인 메소드를 구현하는 데 사용된다.사용자가 정의한 클래스가 다른 데이터 형식과
더불어 잘 동작하게 만들고 싶다면 오버라이딩(overriding)이라고 하는 객체 지향 프로그래밍의
기법을 사용하여 어떤 메소드를 별도로 구현해야 한다(4장에서 자세히 알아볼 것이다.)
예를 들어 ToString()을 오버라이드했다면 클래스는 자기 자신을 문자열로 표현할 수 있는
메소드를 가지게 된다. 만약 클래스 내에 이러한 메소드를 개별적으로 정의해놓지 않는다면
컴파일러는 object 내의 메소드를 그대로 사용할 것이다.

[문자열(String) 형식]

C나 C++에서는 문자열이 단순히 문자의 배열에 지나지 않앗다. 그래서 클라이언트 프로그래머는
어떤 문자열을 다른 문자열로 복사하거나 두개의 문자열을 붙이기 위해 지저분한 코드를
작성해야 했다. 사실 C++에서 문자열의 다양한 작업을 수행하는 클래스를 작성하는 과정은
복잡한 메모리 연산과 API를 필요로 할 뿐만 아니라, 메모리 누수나 오버로드(overload)된
연산자의 많은 버그를 잡아야 하기 때문에 매우 짜증나는 작업이었다.

하지만 C#은 독자적인 문자열 형식을 제공한다. 두 개의 문자열을 붙이거나
문자열을 복사하는등의 작업은 매우 간단하다.

string str1 = "Hello";
string str2 = " World";
string str3 = str1 + str2;

이렇게 값 형식의 변수를 대입하는 것처럼 간단한 형태를 가지고 있음에도 불구하고
CTS의 System.String 형식은 참조 형식이다. 좀더 내부로 들어가 보면 문자열 
객체는 스택이 아니라 힙에 할당된다.그래서 우리가 어떤 문자열 변수를 다른 문자열 
변수로 할당하면 메모리상의 동일한 문자열을 가리키는 두 가지 참조가 생성된다. 
하지만 이 두개의 문자열 중에 하나를 변화시킨다면 다른 문자열은 변화시키지 않고 완전히
새로운 문자열 객체가 생성된다. 다음의 코드를 보자.

using System;

class StringExample{
	public static int Main(){

            string s1 = "A string";
            string s2 = s1;
            Console.WriteLine("s1 is " + s1);
            Console.WriteLine("s2 is " + s2);

            s1 = "Another string ";
            Console.WriteLine("s1 is " + s1);
            Console.WriteLine("s2 is " + s2);

	}
}


다른 말로 s1의 값을 바꾸는 것은 s2에 어떠한 영향도 끼치지 않는다. 그런데 이것은 우리가
지금까지 생각해왔던 참조 형식의 기능과는 모순이다. s1이 "A string"으로 초기화되면 새로운
객체가 힙에 할당된다. s2가 초기화되면 참조는 같은 객체를 가리키게 되고, s2는 "A string"이라는
값을 가지게 된다. 하지만 힙에 할당된 그 객체의 값을 변화시키는 것이라 , s1의 값만 변화시키면
새로운 값을 위하여 새로운 격체가 힙에 할당된다. 그래서 s2 변수는 여전히 최초의 객체를
가리키게 되고 값은 바뀌지 않는 것이다.

문자열은 겹따옴표로 시작하여 겹따옴표로 끝난다. 만약 문자열을 단일따옴표를 이용하여 표시
하면 컴파일러는 그것을 문자로 간주하여 오류를 발생시킬 것이다. C#의 문자열은 문자와 같은
유니코드와 16진수와 이스케이프 시퀸스를 가질 수 있다. 이스케이프 시퀸스는 백슬래시와 함께
사용되므로 우리는 백슬래시를 문자열 내에서 단독으로 사용할 수 없다. 대신 다음과 같이
백슬래시를 하나 덧붙여서 사용할 수 있다.

string filepath = "C:\\경로작렬";

이렇게 사용해야 한다는 것을 항상 기억하고 있다고 하더라도 백슬래시를 두 개 입력한다는 것은
꽤나 번거로운 일이다. 편리하게도 C#은 이렇게 작은 배려도 아끼지 않았다.
문자열 앞에 다음과 같이 @를 붙이면 문자열의 모든 문자는 이스케이프 문자로 인식되지 않고
그래도 인식된다.

string filepath = @"C:\경로작력"

그래서 문자열을 몇 줄로 나누어 쓸 수도 있다.

string Jabberwocky = @ " 'Twas brillig and the slithy 
toves Did gyre and gimble in the wabe."

그런데 위의 방법을 사용하면 문자열이 의도하지 않은 형태를 가지게 될 수도 있다. 아래처럼
문자열에 내용을 두 줄로 나누어 쓰면,

string Jabberwocky = @ " 'Twas brillig and the slithy 
		toves Did gyre and gimble in the wabe."

Jabberwocky의 값은 다음과 같이 된다. 즉 새 줄 문자 하나 이외에 20칸의 빈칸이 포함된다.

'Twas brillig and the slithy toves 				Did...'



[클래스]
클래스는 C#과 .NET 프레임워크에서 사용자가 정의하는 가장 기본적인 데이터 형식이다.
C#으로 작성된 거의 대부분의 실행 파일은 적어도 하나의 클래스를 가지고 있는데
(이론적으론 대신 구조체를 사용할 수 있다), 이것은 프로그램의 진입점인 Main 메소드를 가지고 있다.

클래스는 데이터 멤버(필드, 상수 , 이벤트)과 함수(대부분 메소드와 프로퍼티이지만 연산자나
그 외의 것)로 이루어진 복합적인 데이터 형식이다. 다른 말로 클래스는 어떤 객체를 제어하고
그 객체상에서 작업을 하는데 필요한 모든 데이터와 기능성을 캡슐화시켜 놓은 것이다.


[인터페이스(interface)]
인터페이스는 클래스를 구현하는 기능성을 정의하는 데 사용된다. 인터페이스는 프로퍼티와 메소드,
이벤트 , 인덱스(indexer)를 포함할 수 있으나 인스턴스화 될 수 없고 이러한 함수들의 구현을 
정의하지 못한다. 예를 들면 인터페이스가 함수를 포혐하고 있다면 이것은 함수의 반환 형식과
매개변수들을 정의하고 있지, 실제로 구현하는 코드는 가지고 있지 않다. 인터페이스를
구현하고 있는 클래스는 메소드를 독자적으로 구현해야 한다.





[델리게이트(Delegate)]
델리게이트는 메소드를 참조하는 데이터 형식이다. C++의 함수 포인터와 비슷하나 인스턴스화되어
클래스의 정적 메소드와 클래스의 특정 인스턴스의 메소드들을 호출하는데 사용될 수있다.
그리고 델리게이트를 사용하면 실행 시에 어떤 메소드를 호출하고자 하는지 결정할 수 있다.


[배열(Array)]

C와 C++에서 배열은 단순히 메모리상의 어떤 주소를 가리키고 배열의 인덱스는 단순히
그 주소로부터의 offset을 나타내는 의미에 지나지 않았다. C나 C++에서는 배열을 배열
element에 대한 포인터를 이용하여 참조할 수 있는데, 첫번째 element의 주소값의 포인터에
element의 인덱스를 더하여 배열의 다른 element에 엑세스할 수 있다.

//C++에서는 이 대입문들이 둘 다 유효하고 동일하다.
a[100] = 1;
*(a+100) = 1;

이러한 방식을 사용하면 매우 유연하게 배열을 제어할 수 있을지 모르나 이에 필요한 포인터 연산은
오류를 발생시키기 쉽다. C와 C++는 배열의 크기를 점검하지 않기 떄문에 배열의 경계를 넘어서서 
메모리를 건드릴 수 있다. 그래서 프로그램이 잘못된 연산을 일으키는 경우가 많았다.

//C++에서 이것은 컴파일러가 검출해내지 못한다.
char *pString = new char[50];
pString[100] = '\0'l //100은 배열의 할당된 영역 안에 있지 않다.

이러한 C와 C++의 단점을 극복하기 위해 C#은 배열을 하나의 데이터 형식으로 명확히 정의하였다.
배열을 메소드와 프로퍼티를 가진 객체로 정의함으로써 CLR은 아웃 오브 바운드(out-of-bound, 배열의
크기를 넘어서 배열의 범위 밖의 메모리에 엑세스하여 일어나는 오류) 같은 오류를 사전에 방지할 수
있도록 지원한다. 더 나아가 C#은 프로그램 수행 중에 일어나는 아웃 오브 바운드 오류를 
자동으로 처리하기 위한 특별한 형식의 오류 객체를 제공한다.

[C# 배열의 문법]

C#은 배열에 대해서 독특한 엑세스 방식을 사용하고 있기 때문에 배열의 문법을 유일하게 지정하고 있다.
C 언어에서와 같이 배열을 각 element의 변수 형식의 끝에 대괄호를 열고 닫음으로써 선언할 수 있다.
(배열 안에 모든 element들은 동일한 데이터 형식을 가지고 있어야 한다.)
예를 들면 int는 단일 정수를 나타내는 반면 int[]는 정수의 배열을 나타낸다.

int[] Integers;

배열의 크기를 초기에 정해주고 싶으면 new 키워드를 이용하여 형식 이름 뒤에 대괄호를 쓰고
배열의 크기를 명시해줄 수 있다.

//32개의 정수를 가지는 새로운 배열을 만든다.
int[] Integers = new int[32];

배열 내의 element에 엑세스하기 위해서는 배열 이름 뒤에 대괄호를 쓰고 그 안에 element의
인덱스를 넣어주는 일반적인 문법을 사용한다. 모든 C#배열은 0 기반 인덱스를 사용하기 때문에
배열의 첫번째 element를 인덱스 0으로 참조할 수 있다.

Integers[0] = 35;

마찬가지로 마지막 element인 32번째 element는 31의 인덱스 값으로 참조할 수 있다.

Integers[31] 432;

C#의 배열 문법은 매우 유연하다. C#에서는 배열을 초기화하지 않고 선언할 수 있기 때문에
프로그램상에서 동적으로 크기를 변경할 수 있다. 그래서 기본적으로 null 참조를 만들어 new 키워드에
의해서 할당받은 메모리 영역을 가리키도록 지정할 수 있다.

int[] Integers;
Integers = new int[32];

이 문법은 maloc이나 sizeof를 사용하는 것보다 휠씬 쉽고, 우리가 이 문법을 사용하면 메모리 누수도
잘 일어나지 않는다. C나 C++에서는 배열에 의해 참조되는 메모리 영역이 특별히 해지되지 않는 한
힙에 그대로 남아 있었다. 반대로 C# 배열은 다른 C# 객체처럼 CLR에 의해서 관리되기 때문에,
더 이상 참조되지 않게 되면 자동으로 소멸된다.

C와 C++의 배열이 가진 장점은 중괄호를 통하여 배열의element의 값을 일일이 명시해 줄 수
있었다는 것이다. 다행이도 C#역시 이러한 간편함을 제공하고 있다.

string[] String = {"s1","s2","s3"};

이것 또한 같다.

string[] String = new string[] {"s1","s2","s3"};

하지만 이러한 방법으로 초기화를 하는 경우, 변수를 사용하여 배열의 크기를 명시하는 것은
불가능하며, 모든 형식에 대하여 위와 같은 방법을 사용할 수 있는 것은 아니다.

int len = 3;
//아래 명령문은 컴파일되지 않는다.
string[] String = new String[len] {"s1","s2","s3"};

하지만 상수는 사용할 수는 있다.

const int len = 3;
//허용된다.
string[] String = new String[len] {"s1","s2","s3"};

이 문법을 사용하여 실행 시에 배열의 크기를 결정할 수 없다. 만약 동적으로 크기가 할당되는
배열이나 실행 시에 확장될 수 있는 배열을 원한다면 ArrayList 객체의 인스턴스를 만들어야 한다.
이 객체는 System.Collections 네임스페이스 안에 정의되어 있는데 7장에서 자세히 다룰 것이다.

또한 배열 크기를 초월하여 element들의 값을 할당해 줄 수 없다.

//아래 명령문은 컴파일되지 않는다.
string[] String = new String[3]{"s1","s2","s3","s4"};


[배열로 작업하기]

배열은 C#에서 특별한 데이터 형식이기 때문에 예를 들면 배열의 크기를 알아내는 등 별도의
메소드를 가지고 있다. 그러므로 C#에서 작업하는 것은 매우 쉽다.

예를 들어 1차원 배열의 크기를 알아내기 위해서는 Length 프로퍼티를 사용하면 된다.

int ArrayLength = Integers.Length;

배열이 1차원 이상이라면 GetLength 메소드를 통하여 특정 차원의 크기를 구할 수 있다.

//첫번째 차원의 길이를 구한다.
int ArrayLength = integers.GetLength(0);

만약 배열이 element가 미리 정의된 형식의 일종이라면 Sort 메소드를 이용하여 배열을 
오름차순으로 정렬할 수 있다.

Array.Sort(String);

위에서 배열 인스턴스의 메소드가 아닌 Array 클래스의 정적 메소드를 호출한다는 것을 알아두자.
메소드의 매게변수로 정렬하고자 하는 배열을 넘겨주어야 한다.

다음 짤막한 프로그램은 유명한 예술가들의 이름을 문자열 배열로 저장하고 , 알바벳 반대
순서로 정력한 다음 각 이름을 콘솔 윈도우에 출력하는 예제이다.

//예술가의 이름들의 배열을 정의한다.
string[] Artists = {"Leonardo","Monet","Van Gogh","Kell"};


//배열 element들을 알파벳 순서로 정렬한다.
Array.Sort(Artists);

//배열을 내림차순으로 정렬한다.
Array.Reverse(Artists);

//각 element에 대해서 반복문을 수행하고 이름을 출력한다.
for(int i=0;i<Artists.Length;i++){
Console.WriteLine(Artists[i]);;
}



[C#의 다차원 배열]
C#은 두가지 방식으로 다차원 배열을 지원한다. 하나는 사각 배열이다. 2차원 사각 배열은
모든 행이 같으 개수의 열을 같는 것이다. 다음 예에서 설명하는 것같이 사각 배열은 상대적으로
선언하고 초기화하기 쉽다. 여기에서 각 행이 2개의 열을 가지고 있는 2차원 사각 배열을 선언해보자.


string[,] BeatleName = {{"Lennon","John"}
			,{"McCartney","Paul"}
			,{"Harrison","George"}
			,{"Starkey","Richard"}
			};


사각 배열을 선언할 때 차원을 구분하기 위해서 콤마를 사용하고 , 차원의 크기를 특별히 지정하지
않는다. 3차원 string 배열을 선언하기 위해 다음의 코드를 사용한다.

string[,,] Strings;

배열을 초기화하는 다른 방법은 다음과 같이 중첩된 for 문을 사용 하는 것이다.

double[,] Matrix = new double[10,10];
for(int i=0;i<10;i++){
	for(int j=0;j<10;j++){
	Matrix[i,j] = 4;
	}
}

C#이 지원하는 두번째 다차원 배열은 orthogonal('수직적'이라는 의미를 가지고 있다.) 혹은
소위 jagged('뾰족한'이라는 의미를 가지고 있는데 지그재그의 의미를 떠올리면 된다.) 배열이다.
jagged 이차원 배열의 각 행은 서로 다른 개수의 열을 가질 수 있다. 사각 배열보다 확실히 더
유연하지만 인스턴스를 만들고 초기화하기에는 어려움이 따른다. jagged 배열을 만들기 위해서
일단 배열의 배열을 만들어야 한다.

//jagged 배열을 만든다.
int[][] a = new int[3][];
a[0] = new int[4]
a[1] = new int[3];
a[2] = new int[1];

배열의 차원의 크기를 나타내기 위해서 콤마을 사용하지 않고 각 차윈에 대하여 대괄호 쌍
하나를 사용한다 그러므로 int 형식 변수의 3차원 jagged 배열을 선언하려면 다음과 깉이 한다.

int[][][] Ints;

jagged 배열의 element들을 탐색하는 것은 사각 배열의 element들을 탐삭하는 것보다 더 많은 일이
필요하다. 우선 각 행을 탐색하면서 그 행 안에 몇 개의 열이 있는지 알아내여 하는데,
배열의 GetLength 메소를 사용하면 된다.

//저자의 이름을 포함하는 2차원 배열을 선언한다.
string[][] Novelists = new string[3][];
Novelists[0] = new string[] {"Fyodor","Mikhailvoich","Dostoyevsky"};
Novelists[1] = new string[] {"James","Augustine","Joyce"};
Novelists[2] = new string[] {"Miguel","de Cervantes","Saavedra"};


//소트는 1차원 배열만 가능하다
Array.Sort(Novelists[0]);

//배열의 각 소설가들에 대해서 반복문을 수행한다.
int i;
	for (i = 0; i<Novelists.GetLength(0); i++) {
                int j;
                for (j = 0; j < Novelists[i].GetLength(0); j++) { 
                //현재 이름을 출력한다.
                    Console.WriteLine(Novelists[i][j]+" ");
                }
                //다음 소설가 이름은 새줄에서 시작한다.
                Console.WriteLine("\n");
            }