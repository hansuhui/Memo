전산학이라 불리는 Computer Sciences는 사실 수학의 한 분야로 시작했따고 합니다.
지금도 전세계 대부분의 대학에서 수학과의 한 파트로 존재하기도 합니다.
그래서 인지 순수하게 컴파일 하기 전의 프로그램의 내부를 들여다 보면 98% 연산자와 2%예약어로
구성이 되어있다고 말해도 과언이 아닐 정도입니다.
그렇기 떄문에 연산자를 잘 조합해서 적절히 사용하는 것이 멋지고 좋은 프로그램을 작성하는 
기술이기도 합니다.
이제부터 C언어에서 사용하는 연산자와 문법의 기본이라고 할 수 있는 예약어를 살펴보겠습니다.

C언어의 연산자들은 몇 가지를 제외하면 대부분 저희가 중 고등학교에서 통해 배웠던 것과 같습니다.
하지만 그 몇 가지 다른 연산자들의 의미를 제대로 파악하지 못하게 되면 프로그램을 작성하는데
문제가 아주 많아집니다. 연산자들을 종류별로 설명한 것은 다른 책이나 인터넷 자료에 많이 있으니
참조하고 저는 우선순의를 기본으로 설명하겠습니다. 기본적으로 연산자의 의미와 우선순위를
잘 외오두면 프로그래밍의 사소한 논리적 오류를 줄여줄 뿐만 아니라 포인터와 다른 연산자들
(특히 구조체나 배열 연산자들)이 섞여 있는 복잡한 문장도 이해하기 쉬워집니다.

포인터도 결국 연산자에 불과하니까요.

실제로 제게 배운 것들 중에 가장 위대한 것은 연산자와 연산자 우선순위의 중요성이라고 말하는 분들고 있을 정도입니다.

이 세상의 모든 연산자들은 의미를 갖습니다.
의미 없는 인생이 없든이 의미 없는 연산자는 없습니다.

여러분들이 +연산자를 처음 만났을 때의 충격이 기억납니까? 저는 Integral기호 (∫)를 처음 봤을 때의 충격이 아직도 생생합니다. 설마 여러분들 중 태어나면서부터 덧셈 연산자를 알고 있는 사람이 있나요? 사칙현산이 익숙해진 지금 우리는 *의 의미를 압니다. 따로 설명하지 않아도 a*b라고 하면 누가
시키지 않아도 알아서 둘을 곱합니다. 아닌가요? 

연산자(operator)는 반드시 피 연산자(operand)와 함께 사용합니다.

그래서 피 연산자를 한 개 필요로 하는 연산자를 단항 연산자(unary operator)라 부르고
피 연산자 두개를 필요로 하면 이항 연산자(binary operator), 특이하게 피 연산자 세개를 사용하는 경우 삼항 연산자 (ternary operator)라 합니다. 이항 연산자가 가장 일반적인 경우이므로 여기에서
단항 연산자 삼항 연산자라 지칭하지 않으면 이항 연산자입니다.

C의 연산자들의 의미와 우선순의

[우선순위0 ]
() 괄호 연산자 : 주로 연산자의 우선순위를 높여주는 일과 함수를 호출하는 용도로 사용합니다.
[] 배열 연산자 : 배열을 만들고 메모리를 핸들링 하는 연산자로 배열에서 다시 한번 다룹니다.
-> 포인터로 접근하는 구조체 멤버 연산자 : 구조체를 포인터로 접근하게 되면 ->를 사용합니다.
   -> 안에는 *와 . 이 함께 들어있기 때문입니다 A->B라고 사용하면 (*A).B와 같은 의미가 됩니다.
구조체를 이야기할 때 다시 한번 자세히 설명하겠습니다.

. 구조체 멤버 연산자 : 구조체는 서로 다른 타입의 데이터를 묶어서 사용하기 위한 C언어의 타입입니
다. 대부분의 컴파일러들은 구조체 연산자의 실행 속도를 높이기 위해 멤버들을 실제 사이즈가 아닌
지정 블록 단위로 저장합니다. 때문에 구조체를 사용할 때는 서로 다른 시스템 간의 구조체 교환은
특히 주의 해야 합니다. 역시 구조체 부분에서 자세히 다루겠습니다.
이 네가지 연산자들은 반드시 기억해야 합니다. 어떤 연산자들보다 우선순위도 높을 뿐만 아니라 수학적인 연산자 아니기 떄문에 의미를 잘 기억해야 합니다. 특히 배열이 연산자이며 우선순위가 매우
높다는 걸 알아야 합니다.


우선순위 0.7 : 후행 증감 단항 연산자

++ -- 뒤 증감 연산자 : 밑에 있는 앞 증감 연산들과 같은 동작을 합니다. 사실 이 뒤 증감 연산자에
대한 부분은 대부분 책에 빠져있습니다. 심지어 저도 우선순위가 가장 낮은 줄 알고 그렇게 가르쳤던
적이 있습니다. 하지만 오히려 앞 증감 연산자들보다 우선순위가 높다는 사실을 알게 되었습니다.
현재 많이 사용하고 있는 *pointer++라는 수식은 *(pointer++)와 같은 동작을 합니다. 
괄호를 생략해도 의미가 바뀌지 않는 이유는 괄호 안에 연산자가 우선순위가 높기 때문입니다.
a+b*c와 a+(b*c)는 같은 의미인 것과 같습니다. 
주의할 것은 우선순위가 높다는 것이지 증가되는 동작이 먼저 된다는 것은 절대로 아닙니다. 괄호를
사용 한 경우도 마찬가지 입니다. 실제 증가는 가장 나중에 하게 됩니다. 
'우선순위는 높고 동작은 가능 늦게'이렇게 기억하면 됩니다.
다른 책에 설명이 없는 부분이라 우선순위를 그냥 0.7룰 주었습니다. 관련된 예쩨는 문자열 처리 부분에서 한번 더 다루겠습니다. 여기에서는 우선 증감 연산자가 문장에서 단독으로 사용될 때는 
피 연산자 앞에 있든지 뒤에 있든지  그 결과에 차이가 없지만 다른 연산자와 함께 사용되면
우선순위와 그 의미를 조심해야 한다는 것을 기억해야 합니다.



[우선순위 1 : 단항 연산자들]

! not 눈리연산자 : 참이나 거짓을 바꿔주는 단항 연산자 입니다. 다른 언어나 수학에서의 참
거짓과는 다르게 C언어 에서는 참 거짓이 따로 존재하지 않습니다. 0이 거짓이고 0이 아닌 다른
모든 숫자는 참입니다. 1도 참이고 1004도 참이고 -500도 참이고 3.141592도 참입니다.
때문에 !100값을 보면 0이 되며 !0값을 찍어보면 참의 대표 값인 1이 됩니다. 
다른 언어로의 확장을 위해 0과 1로 define 해서 사용하는 것이 좋은 방법이기는 합니다.

~ 비트 반전 연산자 : 비트를 반전시키는 단항 연산자입니다. 비트(bit)는 binary digit의
줄임 말로 이진수를 말합니다. 컴퓨터가 이진수를 사용한다는 건 이제 널리 알려진 사실입니다.
컴퓨터가 사용하는 이진수의 0 과 1을 서로 바꾸는 연산자입니다. 주로 보수를 만들기 위함입니다.
제가 지는 chapter에서 컴퓨터 구주에 대한 공부를 부탁했습니다. 
컴퓨터 구조를 공부하면 비트 연션자들의 무한한 용도를 깨닫게 될수 있을 것입니다.

* 포인터 연산자 : 포인터 단항 연산자입니다. 여러 장에서 걸쳐 자세히 설명 드리겠습니다. 부디
포인터를 두려워 하지 마세요. 그저 덧셈이나 곱셈 같은 연산자에 불과합니다. 포인터에 관한 가장 큰
오류는 바로 포인터가 어렵다는 것입니다. 익숙해지면 덧셈하듯이 곱셈하듯이 포인터를 사용할 수 있습니다. 여기 제가 증인입니다.

& 주소 연산자 : 주소 단항 연산자 입니다. 실제 메모리의 상대 주소 값을 알려 주는 연산자입니다.
  		주로 포인터 변수에 대입할 때 사용합니다.

++ 앞 증가 연산자 : 정수형 변수의 값을  1증가시키는 단항 연산자입니다. 그러면 그냥 1을 더하지 왜 ++ 이란 연산자를 만들었을까요? 그건 보통의 경우 +연산자는 컴파일러가 add로 번역하지민
++은 increment로 변역하기 떄문입니다. 일반적인 경우 컴퓨터 내부에서 add 보다는 increment가
빠르다고 알려져 있습니다.

-- 앞 증가 연산자 : 정수형 변수의 값을 1감소 시키는 단항 연산자입니다. 마찬가지로 decrement로 변역하게 되고 역시 일반적인 경우 컴퓨터 내부에서 increment 보다는 decrement가 빠르다고 알려져 있습니다. 때문에 순서가 중요하지 않다면 작은 숫자를 ++를 사용하여 증가 시키는 것보다는 
큰 숫자를 --를 사용하여 감소시키는 것이 좋다고 합니다. 이런 것들은 컴퓨터 구조를 배우면 자세히
나와있습니다.

(type) 강제 형 변환 연산자 : 일명 cast연산자라고 부르는 단항 연산자 입니다. 여러분은 캐스팅의
위력을 알고 있나요? 변경되는 데이터의 사이즈가 실제 데이터 사이즈보다  작게 되면 강제로 잘리게
됩니다. 그렇지만 아무리 강제 형 변환이라고 해도 실제 데이터가 변경되는 일은 없습니다.


sizeof 메모리 바이트 크기 연산자 : 데이터가 메모리에 차지하고 있는 공간의 실제 바이트 수를 알려
주는 단항 연산자입니다. 절대로 함수가 아닙니다. 대부분의 컴파일러가 sizeof 연산의 결과는
컴파일 하면서 상수 값으로 미리 정해 놓습니다. 그리고 중요하게 짚고 넘어가야 할 시실은 sizeof의
피연산자가 대입,증감 연산자나 함수 호출 등을 포함하는 수식일 경우 그 수식이 동작하지 않습니다.
 
- 음수 부호 연산자 : 음수와 양수를 반전 시켜주는 negative 단항 연산자입니다.
+ 양수 부호 연산자 : 양수 부호 단항 연산자 입니다.


[우선순위 2:산술연산자들 i]

* 곱셈 연산자 : 곱셈하는 이항 연산자입니다. 

/ 나눗셈 연산자 : 나눗셈하는 이항 연산자입니다.

정수형 / 정수형 == 정수형
정수형 / 실수형 == 실수형
실수형 / 정수형 == 실수형
실수형 / 실수형 == 실수형

% 나머지 연산자 : 정수형 데이터 일 때만 연산 가능한 나머지를 구해주는 이항 연산자입니다.
		  피연산자로 실수형 데이터를 사용하면 컴파일 에러가 발생합니다.

[우선순위 3: 산술 연산자들 ii]

+ 덧셈 연산자 , - 뺄셈 연산자


[우선순위 4:Shift 연산자들]

>> 오픈쪽 시프트 연산자 : 왼쪽에서 오른쪽으로 정해진 수만큼 비투가 전달되는 이항연산자입니다.
가장 왼쪽 비트는 부후가 있는 경우 부호가 채워지며, 부호가 없는 경우 0으로 채워지면서 
가장 오른쪽 비트는 사라집니다. 일반적으로 비트를 확인하거나 빠른 나눗셈을 위해 사용합니다.
m > n 는 / m / 2n 과 같은 동작을 합니다.


<< 왼쪽 시프트 연산자 : 오른쪽에서 왼쪽으로 정해진 수만큼 비트가 전달되는 이항연산입니다.
가장 오른쪽 비트는 0 으로 채워지고 가장 왼쪽 비트는 사라집니다. 일반적으로 비트를 세팅하거나
빠른 곱셈을 위해 사용합니다. m << n 는 m * 2n와 같은 동작을 합니다.

[우선순위 5: 비교연산자들 i]
< > <= >=  크기 비교 연산자 : 데이터 값의 크기를 비교하는 이항 연산자들입니다.

[우선순위 6: 비교 연산자들 ii]

== !=   크기 비교 연산자 : 데이터 값의 크기를 비교하는 이항 연산자들입니다.

[우선순위 7 : 비트 연산자 i ]

& 비트 AND 이항 연산자 : 비트 1과 비트 1이 만날 때만 1입니다. 1011 & 0101 이라고 가정할 때, 
오른쪽 피 연산자의 비트가 1이면 왼쪽으 비트 값이 그대로 전달됩니다. 비트 AND에는 원하는 비트만을 남기는 bit mask 기능이 있습니다.


1011 & 0101 = 0001 

[우선순위 8 : 비트 연산자 ii]

^ 비트 XOR 이항 연산자 : 두 피 연산자의 비트가 서로 다른 때만 1이 됩니다. 비트 XOR에는 
두 데이터 값이 같지 않으면 참이 되는 비교 기능이 있습니다.

1011 ^ 0101 = 1110


[우선순위 10 : 논리 연산자 i]

&& 논리 AND 이항 연산자 : 참 거짓을 판단하는 연산자입니다. 두 피 연산자가 모두 참을 때만 참입니다. 재미있는 사실은 첫 번째 피 연산자가 거짓이면 두 번째 피 연산자의 참 거짓은 판단하지 않는다는 것입니다. 첫 번째 피 연산자가 이미 거짓이니 두 번째 연산자가 참이든 거짓이든 거짓이 분명하기 때문입니다.

[우선순위 11: 논리 연산자 ii]

|| 논리 OR 이항 연산자 : 참 거짓을 판단하는 연산자입니다. 


[우선순위 12: 조건 삼항 연산자]

?: 조건 삼항 연산자 : 참 거짓을 비교하여 참을 때는 colon 기호의 왼쪽을 실행하고 거짓이면
오른쪽을 실행합니다. 

[우선순위 13: 대입 연산자들]

= =* /= %= += -= <<= >>= &= |= ^= 대입연산자들 : 대입연산자들은 우선순위가 매우 낮은 편입니다.
그리고 =를 제외한 나머지를 복합 대입 연산자라고 부릅니다. 복합 대입 연산자를 보면
대입연산자 왼쪽에 오는 연산자들이 산술연산자 , shift 연산자 , 비트 연산자라는 것을 알수 있습니다.


[우선순위 14: 콤마 연산자]
, 콤마 연산자 : 콤마도 연산자였습니다 .콤마는 보통 데이터 수식을 나열 할 때 사용합니다. 우선순위가 가장낮습니다.



[예약어]

auto doble int struct break else long switch
case enum register typedef char extern return union
const float short unsigned continue for signed void
default goto sizeof volatile do if static while


auto : stake에 자리하는 자동변수를 만드는 예약어 (일반적으로 생략)

break : 반복 문을 빠져 나오는 제어문

case : switch문의 조건에 따라 실행하는 제어문

char : 1byte (문자형) 데이터 타입 선언

const : 상수 데이터를 만드는 선언

continue : 반복문의 조건을 체크하는 곳으로 분기하는 제어문

default : switch 문의 case 조건이 없는 경우 실행하는 제어문

do : while 과 결합하는 do{}while 반복문

double : 8 byte 배정도 실수형 데이터 타입 선언문

enum : 열거형 데이터 선언

extern : (주로) 외부 파일이나 범위 밖에 선언된 데이터 선언

float : 4바이트 단정도 실수형 데이터 선언

for : 반복문

goto : label (label 명과 colon으로 구성)을 적은 위치로 무조건 분기하는 제어문

if : 주어진 조건이 참일 때 실행하는 조건문

int : 2byte 또는 4바이트 정수형 데이터 타입 선언

long : 4바이트 정수형 데이터 타입 선언

register : CPU 내부의 레지스터에 데이터 저장을 요청하는 선언

return : 함수를 끝내고 호출한 곳으로 돌아가는 제어문

short : 2바이트 정수형 데이터 타입 선언

sigend : 부호 있는 데이터 타입 선언(일반적으로 생략)

sizeof : 메모리에 저장된 실제 데이터의 바이트를 알려주는 연산자

static : 정적 데이터 선언

switch : 다중 선택 제어문

typedef : 새로운 타입을 만드는 선언

union : 공용체 선언

unsigend : 부호 없는 데이터 선언

void : 타입이나 리턴 값이 없다는 의미의 선언

volatile : 언제든 하드웨어난 interrup 등의 의해 값이 변경될 수 있다는 의미의 선언

while : 반복문


이제 우리는 연산자와 예약어를 가지고 C프로그램을 작성할 것입니다. C 언어로 프로그램을 작성하면
컴퓨터가 바로 알 수 있을까요? 컴퓨터는 일반적으로 이진수를 사용하고 이진수로 되어있는 것만
인식합니다. 그렇다면 프로그램도 이진수로 되어 있는 기계어로 작성해야 할까요? 문론 기계어로 
작성하면 컴퓨터가 더 빨리 알아듣고 실행할 수 있을 것입니다. 마치 중간에 통역을 두지 않고 직접
같은 언어로 대화하는 것처럼 말입니다.
실제로 컴퓨터 프로그래밍의 아버지라 할 수 있는 폰 노이만은 오직 기계어만을 유일한 컴퓨터로
인정해서 기계어로 프로그램을 작성했을 뿐만 아니라 제자들이 어셈블리어라도 사용하면 화를 
냈다고 전해집니다. 저도 아주 가끔 기계어인 실행프로그램을 에디터로 열어서
메시지나 몇 가지 값을 바꿀 때가 있기는 합니다. 하지만 우리는 처음부터 
기계어로 작성 할 수는 없죠.

만약에 아직도 모든 프로그래머들이 기계어로 프로그램을 만들어야 한다면 이 세상에 프로그래머가
얼마나 남아 있겠습니까? 더욱이 나라와 민족마다 다른 언어를 사용하듯이 컴퓨터 CPU의 종류마다
다른 이진수의 조합을 사용합니다. 그렇게 때문에 다양한 언어들이 존재하게 되었고 다양한 언어로 작성된 프로그램을 컴퓨터가 이해하도록 기계어로 바꿔줘야 합니다.

프로그래밍 언어가 다양한것처럼 한 언어에 대해 컴파일러도 다양하게 존재합니다. 컴파일러의 
선택은 여러분들이 사용하는 컴퓨터나 운영체제 또는 프로그래머의 취향에 따라 달라질 수 있습니다.

 

컴파일은 일반적으로 4단계로 동작합니다.

preprocess 단계 : 선행처리기가 동작합니다. 선행처리기는 일반적으로 #으로 시작하는 문법을 
해석하여 컴파일러에게 알립니다. 그리고 또 한가지 주석을 모두 지웁니다. 그래서 실제 컴파일러는
 주석이 있었는지도 모릅니다. 선행처리기 에러는 #으로 시작하는 부분을 살펴봐야 합니다. 자세한
문법은 나중에 자세하게 다룰 것입니다.


compile 단계 : 작은 의미의 컴파일 입니다. 컴파일러는 C문법으로 되어 있는 프로그램을 어셈블리
문법으로 변환합니다. 넓은 의미의 컴파일은 4단계를 모두 다 일컫지만 실제로 컴파일은 이 부분을 
말합니다. 또한 일반적으로 컴파일 에러라고 하는 문법 에러의 대부분은 여기에서 발생합니다.


assemble 단계 : 어셈블러는 컴파일러가 번역한 어셈블리 프로그램을 실제 기계어로 변환합니다.
이 단계에서는 컴파일러가 변환한 문법이므로 거의 에러가 나지 않습니다. 다만 프로그래머가 직접 
작성한 인라인 어셈블리 문법이라면 에러가 발생할 수도 있습니다. assemble 단계가 끝나면 완전한
기계어 프로그램이지만 실제 실행할 수는 없습니다.


link 단계 : 실제 대부분의 프로그램은 매번 작성할 때 마다 모든 기능을 다 포함 시킬 수는 없습니다
그런 작업은 매우 비효울적일 뿐만 아니라 불가능한 일입니다. 그래서 라이브러리를 사용합니다.
또는 이미 기계어로 번역된 소스의 다른 기능을 사용해야 합니다. 이렇게 라이브러리나 다른 번역된
소스를 연결애햐 하는데 이 작업을 링크라 부릅니다. 링크가 끝난 프로그램은 실행이 가능합니다.
ㅎ



 




























